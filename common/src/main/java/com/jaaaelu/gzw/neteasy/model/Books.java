package com.jaaaelu.gzw.neteasy.model;

import java.util.List;

/**
 * Created by Gzw on 2017/8/26 0026.
 */

public class Books {

    /**
     * count : 20
     * start : 0
     * total : 11769
     * books : [{"rating":{"max":10,"numRaters":2896,"average":"8.4","min":0},"subtitle":"微软技术面试心得","author":["《编程之美》小组 编"],"pubdate":"2008-3","tags":[{"count":2077,"name":"算法","title":"算法"},{"count":1448,"name":"编程之美","title":"编程之美"},{"count":1376,"name":"编程","title":"编程"},{"count":989,"name":"面试","title":"面试"},{"count":883,"name":"计算机","title":"计算机"},{"count":566,"name":"程序设计","title":"程序设计"},{"count":493,"name":"微软","title":"微软"},{"count":442,"name":"思维","title":"思维"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s9233126.jpg","binding":"平装","translator":[],"catalog":"第1章 游戏之乐--游戏中碰到的题目\n1.1 让CPU占用率曲线听你指挥\n1.2 中国象棋将帅问题\n1.3 一摞烙饼的排序\n1.4 买书问题\n1.5 快速找出故障机器\n1.6 饮料供货\n1.7 光影切割问题\n1.8 小飞的电梯调度算法\n1.9 高效率地安排见面会\n1.10 双线程高效下载\n1.11 NIM（1）一排石头的游戏\n1.12 NIM（2）\u201c拈\u201d游戏分析\n1.13 NIM（3）两堆石头的游戏\n1.14 连连看游戏设计\n1.15 构造数独\n1.16 24点游戏\n1.17 俄罗斯方块游戏\n1.18 挖雷游戏\n第2章 数字之魅--数字中的技巧\n2.1 求二进制数中1的个数\n2.2 不要被阶乘吓倒\n2.3 寻找发帖\u201c水王\u201d\n2.4 1的数目\n2.5 寻找最大的K个数\n2.6 精确表达浮点数\n2.7 最大公约数问题\n2.8 找符合条件的整数\n2.9 斐波那契（Fibonacci）数列\n2.10 寻找数组中的最大值和最小值\n2.11 寻找最近点对\n2.12 快速寻找满足条件的两个数\n2.13 子数组的最大乘积\n2.14 求数组的子数组之和的最大值\n2.15 子数组之和的最大值（二维）\n2.16 求数组中最长递增子序列\n2.17 数组循环移位\n2.18 数组分割\n2.19 区间重合判断\n2.20 程序理解和时间分析\n2.21 只考加法的面试题\n第3章 结构之法--字符串及链表的探索\n3.1 字符串移位包含的问题\n3.2 电话号码对应英语单词\n3.3 计算字符串的相似度\n3.4 从无头单链表中删除节点\n3.5 最短摘要的生成\n3.6 编程判断两个链表是否相交\n3.7 队列中取最大值操作问题\n3.8 求二叉树中节点的最大距离\n3.9 重建二叉树\n3.10 分层遍历二叉树\n3.11 程序改错\n第4章 数学之趣--数学游戏的乐趣\n4.1 金刚坐飞机问题\n4.2 瓷砖覆盖地板\n4.3 买票找零\n4.4 点是否在三角形内\n4.5 磁带文件存放优化\n4.6 桶中取黑白球\n4.7 蚂蚁爬杆\n4.8 三角形测试用例\n4.9 数独知多少\n4.10 数字哑谜和回文\n4.11 挖雷游戏的概率","ebook_url":"https://read.douban.com/ebook/1523295/","pages":"327","images":{"small":"https://img3.doubanio.com/spic/s9233126.jpg","large":"https://img3.doubanio.com/lpic/s9233126.jpg","medium":"https://img3.doubanio.com/mpic/s9233126.jpg"},"alt":"https://book.douban.com/subject/3004255/","id":"3004255","publisher":"电子工业出版社","isbn10":"7121060744","isbn13":"9787121060748","title":"编程之美","url":"https://api.douban.com/v2/book/3004255","alt_title":"程式之美","author_intro":"","summary":"这本书收集了约60道算法和程序设计题目，这些题目大部分在近年的笔试、面试中出现过，或者是被微软员工热烈讨论过。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。本书的内容分为下面几个部分：\n（1）游戏之乐：从游戏和其他有趣问题出发，化繁为简，分析总结。\n（2）数字之魅：编程的过程实际上就是和数字及字符打交道的过程。这一部分收集了一些好玩的对数字进行处理的题目。\n（3）结构之法：汇集了常见的对字符串、链表、队列，以及树等进行操作的题目。\n（4）数学之趣：列举了一些不需要写具体程序的数学问题，锻炼读者的抽象思维能力。\n书中绝大部分题目都提供了详细的解说。 每道题目后面还有一至两道扩展问题，供读者进一步钻研。\n书中还讲述了面试的各种小故事，告诉读者微软需要什么样的技术人才，重视什么样的能力，如何甄别人才。回答读者关于IT业面试，招聘，职业发展的疑问。这本书的很多题目会出现在IT 行业的各种笔试、面试中，但这本书更深层的意义在于引导读者思考，和读者共享思考之乐，编程之美。","ebook_price":"22.00","price":"40.00元"},{"rating":{"max":10,"numRaters":1250,"average":"9.0","min":0},"subtitle":"","author":["TOBY SEGARAN"],"pubdate":"2009-1","tags":[{"count":2082,"name":"数据挖掘","title":"数据挖掘"},{"count":1656,"name":"机器学习","title":"机器学习"},{"count":1016,"name":"算法","title":"算法"},{"count":793,"name":"人工智能","title":"人工智能"},{"count":754,"name":"编程","title":"编程"},{"count":635,"name":"集体智慧","title":"集体智慧"},{"count":561,"name":"计算机","title":"计算机"},{"count":281,"name":"programming","title":"programming"}],"origin_title":"Programming Collective Intelligence","image":"https://img3.doubanio.com/mpic/s3350961.jpg","binding":"平装","translator":["莫映","王开福"],"catalog":"前言\n第1章　集体智慧导言\n什么是集体智慧\n什么是机器学习\n机器学习的局限\n真实生活中的例子\n学习型算法的其他用途\n第2章　提供推荐\n协作型过滤\n搜集偏好\n寻找相近的用户\n推荐物品\n匹配商品\n构建一个基于del.icio.us的链接推荐系统\n基于物品的过滤\n使用MovieLens数据集\n基于用户进行过滤还是基于物品进行过滤\n练习\n第3章　发现群组\n监督学习和无监督学习\n单词向量\n分级聚类\n绘制树状图\n列聚类\nK-均值聚类\n针对偏好的聚类\n以二维形式展现数据\n有关聚类的其他事宜\n练习\n第4章　搜索与排名\n搜索引擎的组成\n一个简单的爬虫程序\n建立索引\n查询\n基于内容的排名\n利用外部回指链接\n从点击行为中学习\n练习\n第5章　优化\n组团旅游\n描述题解\n成本函数\n随机搜索\n爬山法\n模拟退火算法\n遗传算法\n真实的航班搜索\n涉及偏好的优化\n网络可视化\n其他可能的应用场合\n练习\n第6章　文档过滤\n过滤垃圾信息\n文档和单词\n对分类器进行训练\n计算概率\n朴素分类器\n费舍尔方法\n将经过训练的分类器持久化\n过滤博客订阅源\n对特征检测的改进\n使用Akismet\n替代方法\n练习\n第7章　决策树建模\n预测注册用户\n引入决策树\n对树进行训练\n选择最合适的拆分方案\n以递归方式构造树\n决策树的显示\n对新的观测数据进行分类\n决策树的剪枝\n处理缺失数据\n处理数值型结果\n对住房价格进行建模\n对\u201c热度\u201d评价进行建模\n什么时候使用决策树\n练习\n第8章　构建价格模型\n构造一个样本数据集\nk-最近邻算法\n为近邻分配权重\n交叉验证\n不同类型的变量\n对缩放结果进行优化\n不对称分布\n使用真实数据\u2014\u2014eBay API\n何时使用k-最近邻算法\n练习\n第9章　高阶分类：核方法与SVM\n婚介数据集\n数据中的难点\n基本的线性分类\n分类特征\n对数据进行缩放处理\n理解核方法\n支持向量机\n使用LIBSVM\n基于Facebook的匹配\n练习\n第10章　寻找独立特征\n搜集一组新闻\n先前的方法\n非负矩阵因式分解\n结果呈现\n利用股票市场的数据\n练习\n第11章　智能进化\n什么是遗传编程\n将程序以树形方式表示\n构造初始种群\n测试题解\n对程序进行变异\n交叉\n构筑环境\n一个简单的游戏\n更多可能性\n练习\n第12章　算法总结\n贝叶斯分类器\n决策树分类器\n神经网络\n支持向量机\nk-最近邻\n聚类\n多维缩放\n非负矩阵因式分解\n优化\n附录A：第三方函数库\n附录B：数学公式\n索引","pages":"364","images":{"small":"https://img3.doubanio.com/spic/s3350961.jpg","large":"https://img3.doubanio.com/lpic/s3350961.jpg","medium":"https://img3.doubanio.com/mpic/s3350961.jpg"},"alt":"https://book.douban.com/subject/3288908/","id":"3288908","publisher":"电子工业出版社","isbn10":"7121075393","isbn13":"9787121075391","title":"集体智慧编程","url":"https://api.douban.com/v2/book/3288908","alt_title":"Programming Collective Intelligence","author_intro":"Toby Segaran是Genstruct公司的软件开发主管，这家公司涉足计算生物领域，他本人的职责是设计算法，并利用数据挖掘技术来辅助了解药品机理。Toby Segaran还为其他几家公司和数个开源项目服务，帮助它们从收集到的数据当中分析并发掘价值。除此以外，Toby Segaran还建立了几个免费的网站应用，包括流行的tasktoy和Lazybase。他非常喜欢滑雪与品酒，其博客地址是blog.kiwitobes.com，现居于旧金山。","summary":"本书以机器学习与计算统计为主题背景，专门讲述如何挖掘和分析Web上的数据和资源，如何分析用户体验、市场营销、个人品味等诸多信息，并得出有用的结论，通过复杂的算法来从Web网站获取、收集并分析用户的数据和反馈信息，以便创造新的用户价值和商业价值。全书内容翔实，包括协作过滤技术（实现关联产品推荐功能）、集群数据分析（在大规模数据集中发掘相似的数据子集）、搜索引擎核心技术（爬虫、索引、查询引擎、PageRank算法等）、搜索海量信息并进行分析统计得出结论的优化算法、贝叶斯过滤技术（垃圾邮件过滤、文本过滤）、用决策树技术实现预测和决策建模功能、社交网络的信息匹配技术、机器学习和人工智能应用等。\n本书是Web开发者、架构师、应用工程师等的绝佳选择。","series":{"id":"697","title":"博文视点O'reilly系列"},"price":"59.80元"},{"rating":{"max":10,"numRaters":1788,"average":"9.2","min":0},"subtitle":"第2版","author":["Jon Bentley"],"pubdate":"2008-10","tags":[{"count":1781,"name":"编程","title":"编程"},{"count":1766,"name":"算法","title":"算法"},{"count":946,"name":"编程艺术","title":"编程艺术"},{"count":896,"name":"计算机","title":"计算机"},{"count":623,"name":"程序设计","title":"程序设计"},{"count":411,"name":"算法与数据结构","title":"算法与数据结构"},{"count":384,"name":"计算机科学","title":"计算机科学"},{"count":331,"name":"programming","title":"programming"}],"origin_title":"Programming Pearls Second Edition","image":"https://img3.doubanio.com/mpic/s4687321.jpg","binding":"平装","translator":["黄倩","钱丽艳"],"catalog":"第一部分　基础\n第1章　开篇\n1.1　一次友好的对话\n1.2　准确的问题描述\n1.3　程序设计\n1.4　实现概要\n1.5　原理\n1.6　习题\n1.7　深入阅读\n第2章　啊哈！算法\n2.1　三个问题\n2.2　无处不在的二分搜索\n2.3　基本操作的威力\n2.4　排序\n2.5　原理\n2.6　习题\n2.7　深入阅读\n2.8　变位词程序的实现（边栏）\n第3章　数据决定程序结构\n3.1　一个调查程序\n.　　3.2　格式信函编程\n3.3　一组示例\n3.4　结构化数据\n3.5　用于特殊数据的强大工具\n3.6　原理\n3.7　习题\n3.8　深入阅读\n第4章　编写正确的程序\n4.1　二分搜索的挑战\n4.2　编写程序\n4.3　理解程序\n4.4　原理\n4.5　程序验证的角色\n4.6　习题\n4.7　深入阅读\n第5章　编程小事\n5.1　从伪代码到c程序\n5.2　测试工具\n5.3　断言的艺术\n5.4　自动测试\n5.5　计时\n5.6　完整的程序\n5.7　原理\n5.8　习题\n5.9　深入阅读\n5.10　调试（边栏）\n第二部分　性能\n第6章　程序性能分析\n6.1　实例研究\n6.2　设计层面\n6.3　原理\n6.4　习题\n6.5　深入阅读\n第7章　粗略估算\n7.1　基本技巧\n7.2　性能估计\n7.3　安全系数\n7.4　little定律\n7.5　原理\n7.6　习题\n7.7　深入阅读\n7.8　日常生活中的速算（边栏）\n第8章　算法设计技术\n8.1　问题及简单算法\n8.2　两个平方算法\n8.3　分治算法\n8.4　扫描算法\n8.5　实际运行时间\n8.6　原理\n8.7　习题\n8.8　深入阅读\n第9章　代码调优\n9.1　典型的故事\n9.2　急救方案集锦\n9.3　大手术\u2014\u2014二分搜索\n9.4　原理\n9.5　习题\n9.6　深入阅读\n第10章　节省空间\n10.1　关键在于简单\n10.2　示例问题\n10.3　数据空间技术\n10.4　代码空间技术\n10.5　原理\n10.6　习题\n10.7　深入阅读\n10.8　巨大的节省（边栏）\n第三部分　应用\n第11章　排序\n11.1　插入排序\n11.2　一种简单的快速排序\n11.3　更好的几种快速排序\n11.4　原理\n11.5　习题\n11.6　深入阅读\n第12章　取样问题\n12.1　问题\n12.2　一种解决方案\n12.3　设计空间\n12.4　原理\n12.5　习题\n12.6　深入阅读\n第13章　搜索\n13.1　接口\n13.2　线性结构\n13.3　二分搜索树\n13.4　用于整数的结构\n13.5　原理\n13.6　习题\n13.7　深入阅读\n13.8　一个实际搜索问题（边栏）\n第14章　堆\n14.1　数据结构\n14.2　两个关键函数\n14.3　优先级队列\n14.4　一种排序算法\n14.5　原理\n14.6　习题\n14.7　深入阅读\n第15章　字符串\n15.1　单词\n15.2　短语\n15.3　生成文本\n15.4　原理\n15.5　习题\n15.6　深入阅读\n第1版跋\n第2版跋\n附录a　算法分类\n附录b　估算测试\n附录c　时空开销模型\n附录d　代码调优法则\n附录e　用于搜索的c++类\n部分习题提示\n部分习题答案\n索引","pages":"228","images":{"small":"https://img3.doubanio.com/spic/s4687321.jpg","large":"https://img3.doubanio.com/lpic/s4687321.jpg","medium":"https://img3.doubanio.com/mpic/s4687321.jpg"},"alt":"https://book.douban.com/subject/3227098/","id":"3227098","publisher":"人民邮电出版社","isbn10":"711517928X","isbn13":"9787115179289","title":"编程珠玑","url":"https://api.douban.com/v2/book/3227098","alt_title":"Programming Pearls Second Edition","author_intro":"Jon Bentley 世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基-梅隆大学（1976~1982）、贝尔实验室（1982~2001）和Avaya实验室（2001年至今）。在卡内基-梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr.Dobb's程序设计卓越奖。","summary":"本书是计算机科学方面的经典名著。书的内容围绕程序设计人员面对的一系列实际问题展开。作者Jon Bentley 以其独有的洞察力和创造力，引导读者理解这些问题并学会解决方法，而这些正是程序员实际编程生涯中至关重要的。本书的特色是通过一些精心设计的有趣而又颇具指导意义的程序，对实用程序设计技巧及基本设计原则进行了透彻而睿智的描述，为复杂的编程问题提供了清晰而完备的解决思路。本书对各个层次的程序员都具有很高的阅读价值。.\n多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力，从磨砺程序员的实际问题中凝结出一篇篇不朽的编程\u201c珠玑\u201d，成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏，最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。..\n在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。...","series":{"id":"660","title":"图灵程序设计丛书"},"price":"39.00元"},{"rating":{"max":10,"numRaters":2789,"average":"9.1","min":0},"subtitle":"","author":["[美] Bruce Eckel"],"pubdate":"2007-6","tags":[{"count":2633,"name":"Java","title":"Java"},{"count":1029,"name":"编程思想","title":"编程思想"},{"count":796,"name":"编程","title":"编程"},{"count":722,"name":"TinkingInJava","title":"TinkingInJava"},{"count":635,"name":"计算机","title":"计算机"},{"count":485,"name":"程序设计","title":"程序设计"},{"count":398,"name":"经典","title":"经典"},{"count":297,"name":"软件开发","title":"软件开发"}],"origin_title":"Thinking in Java","image":"https://img3.doubanio.com/mpic/s27243455.jpg","binding":"平装","translator":["陈昊鹏"],"catalog":"读者评论\n前言\n简介\n第1章 对象导论\n1.1 抽象过程\n1.2 每个对象都有一个接口\n1.3 每个对象都提供服务\n1.4 被隐藏的具体实现\n1.5 复用具体实现\n1.6 继承\n1.6.1 \u201c是一个\u201d（is-a）与\u201c像是一个\u201d（is-like-a）关系\n1.7 伴随多态的可互换对象\n1.8 单根继承结构\n1.9 容器\n1.9.1 参数化类型（范型）\n1.10 对象的创建和生命期\n1.11 异常处理：处理错误\n1.12 并发编程\n1.13 Java与Internet\n1.13.1 Web是什么\n1.13.2 客户端编程\n1.13.3 服务器端编程\n1.22 总结\n第2章 一切都是对象\n2.1 用引用操纵对象\n2.2 必须由你创建所有对象\n2.2.1 存储到什么地方\n2.2.2 特例：基本类型\n2.2.3 Java中的数组\n2.3 永远不需要销毁对象\n2.3.1 作用域\n2.3.2 对象的作用域\n2.4 创建新的数据类型：类\n2.4.1 域和方法\n2.4.2 基本成员默认值\n2.5 方法、参数和返回值\n2.5.1 参数列表\n2.6 构建一个Java程序\n2.6.1 名字可见性\n2.6.2 运用其他构件\n2.6.3 static 关键字\n2.7 你的第一个Java程序\n编译和运行\n2.8 注释和嵌入式文档\n2.8.1 注释文档\n2.8.2 语法\n2.8.3 嵌入式HTML\n2.8.4 一些标签示例\n2.8.5 文档示例\n2.9 编码风格\n2.10 总结\n2.11 练习\n第3章 操作符\n3.1 更简单的打印语句\n3.2 使用Java操作符\n3.3 优先级\n3.4 赋值\n3.4.1 方法调用中的别名问题\n3.5 算术操作符\n3.5.1 一元加、减操作符\n3.6 自动递增和递减\n3.7 关系操作符\n3.7.1 测试对象的等价性\n3.8 逻辑操作符\n3.8.1 短路\n3.9 直接常量\n3.9.1 指数记数法\n3.10 按位操作符\n3.11 移位操作符\n3.12 三元操作符 if-else\n3.13 字符串操作符 + 和 +=\n3.14 使用操作符时常犯的错误\n3.15 类型转换操作符\n3.15.1 截尾和舍入\n3.15.2提升\n3.16 Java没有\u201csizeof\u201d\n3.17 操作符小结\n3.18 总结\n第4章 控制执行流程\n4.1 true和false\n4.2 if-else\n4.3 迭代\n4.3.1 do-while\n4.3.2 for\n4.3.3 逗号操作符\n4.4 Foreach语法\n4.5 return\n4.6 break和 continue\n4.7 臭名昭著的\u201cgoto\u201d\n4.8 switch\n4.9 总结\n第5章 初始化与清理\n5.1 用构造器确保初始化\n5.2 方法重载\n5.2.1 区分重载方法\n5.2.2 涉及基本类型的重载\n5.2.3 以返回值区分重载方法\n5.3 缺省构造器\n5.4 this关键字\n5.4.1 在构造器中调用构造器\n5.4.2 static的含义\n5.5 清理：终结处理和垃圾回收\n5.5.1 finalize()的用途何在\n5.5.2 你必须实施清理\n5.5.3 终结条件\n5.5.4 垃圾回收器如何工作\n5.6 成员初始化\n5.6.1 指定初始化\n5.7 构造器初始化\n5.7.1 初始化顺序\n5.7.2. 静态数据的初始化\n5.7.3. 显式的静态初始化\n5.7.4. 非静态实例初始化\n5.8 数组初始化\n5.8.1 可变参数列表\n5.9 枚举类型\n5.10 总结\n第6章 访问权限控制\n第7章 复用类\n第8章 多态\n第9章 接口\n第10章 内部类\n第11章 持有对象\n第12章 通过异常处理错误\n第13章 字符串\n第14章 类型信息\n第15章 泛型\n第16章 数组\n第17章 容器深入研究\n第18章 Java I/O系统\n第19章 枚举类型\n第20章 注解\n第21章 并发\n第22章 图形化用户界面\n附录A 补充材料\n可下载的补充材料\nThinking in C：Java的基础\nJava编程思想 研讨课\nHands-on Java研讨课CD\nThinking in Objects研讨课\nThinking in Enterprise Java\nThinking in Patterns(with Java)\nThinking in Patterns研讨课\n设计咨询与复审\n附录B 资源\n软件\n编辑器与IDE\n书籍\n分析与设计\nPython\n我的著作列表\n索引","pages":"880","images":{"small":"https://img3.doubanio.com/spic/s27243455.jpg","large":"https://img3.doubanio.com/lpic/s27243455.jpg","medium":"https://img3.doubanio.com/mpic/s27243455.jpg"},"alt":"https://book.douban.com/subject/2130190/","id":"2130190","publisher":"机械工业出版社","isbn10":"7111213823","isbn13":"9787111213826","title":"Java编程思想 （第4版）","url":"https://api.douban.com/v2/book/2130190","alt_title":"Thinking in Java","author_intro":"Bruce Eckel是MindView公司（www.MindView.net）的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想 第2卷》（这两本书的英文影印版及中文版均已由机械工业出版社引进出版）及其他著作。他已经发表了150多篇论文，还经常参加世界各地的研讨会并进行演讲。","summary":"本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。\n从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。\n第4版特点：\n适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5/6增加了新的示例和章节。\n 测验框架显示程序输出。","series":{"id":"1163","title":"计算机科学丛书"},"price":"108.00元"},{"rating":{"max":10,"numRaters":1990,"average":"9.0","min":0},"subtitle":"","author":["Eric S. Raymond"],"pubdate":"2006-2","tags":[{"count":2383,"name":"UNIX","title":"UNIX"},{"count":1080,"name":"编程","title":"编程"},{"count":882,"name":"编程艺术","title":"编程艺术"},{"count":664,"name":"计算机","title":"计算机"},{"count":368,"name":"文化","title":"文化"},{"count":367,"name":"programming","title":"programming"},{"count":302,"name":"linux","title":"linux"},{"count":280,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s1631790.jpg","binding":"平装","translator":["姜宏","何源","蔡晓俊"],"catalog":"","pages":"525","images":{"small":"https://img3.doubanio.com/spic/s1631790.jpg","large":"https://img3.doubanio.com/lpic/s1631790.jpg","medium":"https://img3.doubanio.com/mpic/s1631790.jpg"},"alt":"https://book.douban.com/subject/1467587/","id":"1467587","publisher":"电子工业出版社","isbn10":"7121021161","isbn13":"9787121021169","title":"UNIX编程艺术","url":"https://api.douban.com/v2/book/1467587","alt_title":"","author_intro":"","summary":"本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。","price":"59.00元"},{"rating":{"max":10,"numRaters":2084,"average":"9.4","min":0},"subtitle":"第2版","author":["W.Richard Stevens","Stephen A.Rago"],"pubdate":"2006年","tags":[{"count":2071,"name":"unix","title":"unix"},{"count":1327,"name":"编程","title":"编程"},{"count":947,"name":"Linux","title":"Linux"},{"count":608,"name":"计算机","title":"计算机"},{"count":507,"name":"经典","title":"经典"},{"count":499,"name":"programming","title":"programming"},{"count":312,"name":"程序设计","title":"程序设计"},{"count":278,"name":"C","title":"C"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s4436543.jpg","binding":"平装","translator":["尤晋元","张亚英","戚正伟"],"catalog":"","pages":"758","images":{"small":"https://img3.doubanio.com/spic/s4436543.jpg","large":"https://img3.doubanio.com/lpic/s4436543.jpg","medium":"https://img3.doubanio.com/mpic/s4436543.jpg"},"alt":"https://book.douban.com/subject/1788421/","id":"1788421","publisher":"人民邮电出版社","isbn10":"7115147310","isbn13":"9787115147318","title":"UNIX环境高级编程","url":"https://api.douban.com/v2/book/1788421","alt_title":"Advanced Programming in the UNIX Environment","author_intro":"W.Richard Stevens，备受赞誉的技术作家，生前著有多种经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP/IP详解》（三卷本）和本书第1版。 尤晋元，上海交通大学计算机科学及工程系教 授、博士生导师。在科研方面，主要从事操作系统和分布对象计算技术方面的研究；在教学方面，长期承担操作系统及分布计算等课程的教学工作。主编和翻译了多本操作系统教材和参考书，包括《UNIX操作系统教程》、《UNIX高级编程技术》、《UNIX环境高级编程》和《操作系统：设计与实现》等。","summary":"本书是被誉为UNIX编程\u201c圣经\u201d的Advanced Programming in the UNIX Environment一书的更新版。在本书第1版出版后的十几年中，UNIX行业已经有了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持了前一版风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。书中除了介绍UNIX文件和目录、标准I/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了多个应用示例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外，还在附录中给出了函数原型和部分习题的答案。\r\n    本书内容权威，概念清晰，阐述精辟，对于所有层次UNIX程序员都是一本不可或缺的参考书。","price":"99.00元"},{"rating":{"max":10,"numRaters":1753,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1057,"name":"C语言","title":"C语言"},{"count":609,"name":"编程","title":"编程"},{"count":374,"name":"c","title":"c"},{"count":357,"name":"计算机","title":"计算机"},{"count":320,"name":"C专家编程","title":"C专家编程"},{"count":297,"name":"C/C++","title":"C/C++"},{"count":287,"name":"C","title":"C"},{"count":260,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img3.doubanio.com/mpic/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 \u201c安静的改变\u201d究竟有多少安静\n1.11 轻松一下\u2014\u2014由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下\u2014\u2014有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下\u2014\u2014驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下\u2014\u2014回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下\u2014\u2014看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下\u2014\u2014卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下\u2014\u2014\u201cThing King\u201d和\u201c页面游戏\u201d\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下\u2014\u2014国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下\u2014\u2014软件/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下\u2014\u2014程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象\u2014\u2014取事物的本质特性\n11.3 封装\u2014\u2014把相关的类型、数据和函数组合在一起\n11.4 展示一些类\u2014\u2014用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承\u2014\u2014复用已经定义的操作\n11.9 多重继承\u2014\u2014从两个或更多的基类派生\n11.10 重载\u2014\u2014作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入/输出(I/O)\n11.13 多态\u2014\u2014运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意\u2014\u2014多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下\u2014\u2014死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img3.doubanio.com/spic/s5886086.jpg","large":"https://img3.doubanio.com/lpic/s5886086.jpg","medium":"https://img3.doubanio.com/mpic/s5886086.jpg"},"alt":"https://book.douban.com/subject/2377310/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https://api.douban.com/v2/book/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":944,"average":"8.9","min":0},"subtitle":"","author":["本特利"],"pubdate":"2004-4","tags":[{"count":664,"name":"编程","title":"编程"},{"count":520,"name":"算法","title":"算法"},{"count":367,"name":"编程珠玑","title":"编程珠玑"},{"count":280,"name":"计算机","title":"计算机"},{"count":213,"name":"程序设计","title":"程序设计"},{"count":179,"name":"programming","title":"programming"},{"count":118,"name":"编程基本功","title":"编程基本功"},{"count":117,"name":"经典","title":"经典"}],"origin_title":"Programming Pearls Second Edition","image":"https://img3.doubanio.com/mpic/s2484300.jpg","binding":"平装","translator":["本特利著"],"catalog":"\n      ","pages":"217","images":{"small":"https://img3.doubanio.com/spic/s2484300.jpg","large":"https://img3.doubanio.com/lpic/s2484300.jpg","medium":"https://img3.doubanio.com/mpic/s2484300.jpg"},"alt":"https://book.douban.com/subject/1230206/","id":"1230206","publisher":"中国电力出版社","isbn10":"7508319141","isbn13":"9787508319148","title":"编程珠玑(第二版)","url":"https://api.douban.com/v2/book/1230206","alt_title":"Programming Pearls Second Edition","author_intro":"Jon Bentley，世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基\u2014梅隆大学(1976\u20141982)、贝尔实验室(1982\u20142001)和Avaya实验室(2001年至今)。在卡内基\u2014梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr．Dobb's程序设计卓越奖。","summary":"《编程珠玑(第2版)》是计算机科学方面的经典名著。书的内容围绕程序设计人员面对的一系列实际问题展开。作者Jon Bentley 以其独有的洞察力和创造力，引导读者理解这些问题并学会解决方法，而这些正是程序员实际编程生涯中至关重要的。","price":"28.00元"},{"rating":{"max":10,"numRaters":533,"average":"8.4","min":0},"subtitle":"15位软件先驱访谈录","author":["Peter Seibel"],"pubdate":"2011-1-1","tags":[{"count":694,"name":"编程","title":"编程"},{"count":450,"name":"程序员","title":"程序员"},{"count":425,"name":"计算机","title":"计算机"},{"count":320,"name":"传记","title":"传记"},{"count":179,"name":"思维","title":"思维"},{"count":159,"name":"软件开发","title":"软件开发"},{"count":152,"name":"Programming","title":"Programming"},{"count":123,"name":"软件工程","title":"软件工程"}],"origin_title":"Coders at Work","image":"https://img3.doubanio.com/mpic/s4549954.jpg","binding":"平装","translator":["图灵俱乐部"],"catalog":"第1篇 Jamie Zawinski\t1\n第2篇 Brad Fitzpatrick\t37\n第3篇 Douglas Crockford\t69\n第4篇 Brendan Eich\t101\n第5篇 Joshua Bloch\t129\n第6篇 Joe Armstrong\t157\n第7篇 Simon Peyton Jones\t185\n第8篇 Peter Norvig\t221\n第9篇 Guy Steele\t253\n第10篇 Dan Ingalls\t289\n第11篇 L Peter Deutsch\t321\n第12篇 Ken Thompson\t347\n第13篇 Fran Allen\t375\n第14篇 Bernie Cosell\t401\n第15篇 Donald Knuth\t435\n参考书目\t471","pages":"473","images":{"small":"https://img3.doubanio.com/spic/s4549954.jpg","large":"https://img3.doubanio.com/lpic/s4549954.jpg","medium":"https://img3.doubanio.com/mpic/s4549954.jpg"},"alt":"https://book.douban.com/subject/5355285/","id":"5355285","publisher":"人民邮电出版社","isbn10":"711523907X","isbn13":"9787115239075","title":"编程人生","url":"https://api.douban.com/v2/book/5355285","alt_title":"Coders at Work","author_intro":"Peter Seibel  Common Lisp专家，Jolt生产效率大奖图书Practical Common Lisp的作者。耶鲁大学英语专业毕业，后投身于互联网行业，曾负责Mother Jones Magazine和Organic Online的Perl专栏以及WebLogic的Java专栏，并曾在加州大学伯克利分校成人教育学院教授Java编程。2003年辞职专心研究Lisp编程，之后即有了那部Jolt大奖图书。现在他是Gigamonkeys Consulting公司的首席执行官，和家人幸福地生活在加州伯克利。","summary":"界顶尖的程序员是怎么走上编程道路的？\n他们的编程工作创造和改变了人类历史，在这一过程中都有哪些经验和教训？\n他们对计算机软件行业的过去、现在和未来有什么独到的看法和见解？\n他们对培养、发现、选拔、面试优秀的程序员有什么建议？\n放下手头的工作，听听这些软件先驱们的故事和建议，眼界可以更开阔，思路可以更清晰，方向可以更明确，人生可以更精彩。\n作者Peter Seibel采访了下面这15位世界级编程大师，本书是他在近80个小时的访谈录音基础上整理汇编而成的。\n        Jamie Zawinski：Lisp程序员，XEmacs开发者，Netscape浏览器和Mozilla核心开发者。\n        Brad Fitzpatrick：书中唯一的80后，LiveJournal和memcached开发者。现效力于Google。\n        Douglas Crockford：JavaScript权威，JSON之父。现任Yahoo架构师。\n        Brendan Eich：JavaScript之父。Mozilla公司CTO。\n        Joshua Bloch：如果说Gosling是Java之父，那Bloch就是使Java真正成熟的教父，Java 2到5的核心架构师。现为Google首席Java架构师。\n        Joe Armstrong：Erlang和OTP（开放电信平台）框架之父。\n        Simon Peyton Jones：Haskell先驱。ACM会士。现为微软剑桥研究院研究员。\n        Peter Norvig：Google研发总监。ACM会士。\n        Guy Steele：精通多门语言，Common Lisp和Scheme开发者之一，Java语言规范作者之一，Common Lisp、Fortran、C、ECMAScript和Scheme等语言标准化委员会成员。高性能科学计算的语言Fortress设计者。ACM会士，美国工程院院士。Sun公司院士。\n        Dan Ingalls：与Alan Kay合作开发了Smalltalk，是该语言的真正实现者。现为Sun公司杰出工程师。\n        L. Peter Deutsch：JIT（即时）编译技术发明者之一，PostScript文件浏览器GhostScript的作者。ACM会士。Sun公司院士。\n        Ken Thompson：图灵奖得主。Unix之父。UTF-8 Unicode编码设计者。\n        Fran Allen：图灵奖第一位女得主。编译技术公认权威。IEEE院士，ACM会士，美国工程院院士。IBM院士。\n        Bernie Cosell：Internet奠基人，ARPANET最早的路由计算机IMP设计者之一。\n        Donald Knuth：多卷本经典巨著《计算机程序设计艺术》的作者，排版软件TeX的作者，图灵奖得主。","price":"79.00元"},{"rating":{"max":10,"numRaters":864,"average":"9.4","min":0},"subtitle":"第1卷:套接口API(第3版)","author":["史蒂文斯","芬纳","鲁道夫"],"pubdate":"2006-1","tags":[{"count":994,"name":"UNIX","title":"UNIX"},{"count":890,"name":"网络编程","title":"网络编程"},{"count":335,"name":"网络","title":"网络"},{"count":291,"name":"编程","title":"编程"},{"count":238,"name":"计算机","title":"计算机"},{"count":200,"name":"linux","title":"linux"},{"count":142,"name":"network","title":"network"},{"count":135,"name":"programming","title":"programming"}],"origin_title":"Unix Network Programming","image":"https://img3.doubanio.com/mpic/s1613283.jpg","binding":"平装","translator":["杨继张"],"catalog":"","pages":"848","images":{"small":"https://img3.doubanio.com/spic/s1613283.jpg","large":"https://img3.doubanio.com/lpic/s1613283.jpg","medium":"https://img3.doubanio.com/mpic/s1613283.jpg"},"alt":"https://book.douban.com/subject/1500149/","id":"1500149","publisher":"清华大学出版社","isbn10":"7302119740","isbn13":"9787302119746","title":"UNIX网络编程","url":"https://api.douban.com/v2/book/1500149","alt_title":"Unix Network Programming","author_intro":"","summary":"《UNIX网络编程》(第1卷)(套接口API第3版)第1版和第2版由已故UNIX网络专家W. Richard Stevens博士独自编写。《UNIX网络编程》(第1卷)(套接口API第3版)是3版，由世界著名网络专家Bill Fenner和Andrew M. Rudoff执笔，根据近几年网络技术的发展，对上一版进行全面修订，增添了IPv6的更新过的信息、SCTP协议和密钥管理套接口的内容，删除了X/Open传输接口的内容。\n《UNIX网络编程》(第1卷)(套接口API第3版)内容详尽且具权威性，几乎每章都提供精选的习题，是计算机和网络专业高年级本科生和研究生的首选教材，《UNIX网络编程》(第1卷)(套接口API第3版)也可作为网络研究和开发人员的自学教材和参考书。","price":"98.00元"},{"rating":{"max":10,"numRaters":1099,"average":"8.7","min":0},"subtitle":"","author":["Jeremy Keith"],"pubdate":"2006年12月","tags":[{"count":1120,"name":"javascript","title":"javascript"},{"count":467,"name":"dom","title":"dom"},{"count":345,"name":"web开发","title":"web开发"},{"count":216,"name":"web","title":"web"},{"count":196,"name":"JavaScript","title":"JavaScript"},{"count":185,"name":"编程","title":"编程"},{"count":145,"name":"入门","title":"入门"},{"count":142,"name":"脚本语言","title":"脚本语言"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s1958902.jpg","binding":"简裝本","translator":["杨涛","王建桥","杨晓云"],"catalog":"第1章 javascript简史 1\n1.1　javascript的起源 2\n1.2　浏览器之争 3\n1.2.1　dhtml 3\n1.2.2　浏览器之间的冲突 4\n1.3　制定标准 5\n1.3.1　浏览器以外的考虑 5\n1.3.2　浏览器之争的结局 6\n1.3.3　新的开始 6\n1.4　小结 7\n第2章 javascript语法 9\n2.1　准备工作 9\n2.2　语法 11\n2.3　语句 11\n2.4　变量 13\n2.4.1　数据类型 15\n2.4.2　数组 17\n2.5　操作 20\n2.6　条件语句 22\n2.6.1　比较操作符 23\n.2.6.2　逻辑操作符 24\n2.7　循环语句 25\n2.7.1　while 25\n2.7.2　do...while 26\n2.7.3　for 27\n2.8　函数 27\n2.9　对象 31\n2.9.1　内建对象 32\n2.9.2　宿主对象 33\n2.10　小结 33\n第3章 dom 35\n3.1　文档：dom中的\u201cd\u201d 35\n3.2　对象：dom中的\u201co\u201d 35\n3.3　模型：dom中的\u201cm\u201d 36\n3.3.1　节点 38\n3.3.2　getelementbyid()方法 42\n3.3.3　getelementsbytagname()方法 44\n3.4　趁热打铁 46\n3.4.1　getattribute()方法 46\n3.4.2　setattribute()方法 48\n3.5　小结 49\n第4章 案例研究：javascript美术馆 51\n4.1　编写标记语言文档 52\n4.2　编写javascript函数 54\n4.2.1　dom之前的解决方案 55\n4.2.2　showpic()函数的代码清单 56\n4.3　javascript函数的调用 56\n4.4　对javascript函数进行功能扩展 59\n4.4.1　childnodes属性 59\n4.4.2　nodetype属性 60\n4.4.3　在html文档里增加一段描述性文本 61\n4.4.4　用javascript代码改变＜p＞元素的文本内容 62\n4.4.5　nodevalue属性 63\n4.4.6　firstchild和lastchild属性 63\n4.4.7　利用nodevalue属性刷新＜p＞元素的文本内容 64\n4.5　小结 68\n第5章 javascript编程原则和良好习惯 69\n5.1　不要误解javascript 69\n5.1.1　不要归罪于javascript 70\n5.1.2　flash的遭遇 71\n5.1.3　质疑 72\n5.2　预留退路 72\n5.2.1　\u201cjavascript:\u201d伪协议 74\n5.2.2　内嵌的事件处理函数 74\n5.2.3　有何不好 74\n5.3　向css学习 75\n5.4　分离javascript 78\n5.5　向后兼容性 80\n5.6　小结 82\n第6章 案例研究：javascript美术馆改进版 83\n6.1　快速回顾 84\n6.2　解决\u201c预留退路\u201d问题 84\n6.3　解决\u201c分离javascript\u201d问题 85\n6.3.1　添加事件处理函数 86\n6.3.2　进行必要的检查 87\n6.3.3　创建必要的变量 89\n6.3.4　创建循环 90\n6.3.5　完成必要的操作 91\n6.3.6　完成javascript函数 91\n6.3.7　把多个javascript函数绑定到onload事件处理函数上 92\n6.4　javascript函数的优化：不要做太多的假设 94\n6.4.1　不放过每个细节 97\n6.4.2　键盘浏览功能 99\n6.4.3　慎用onkeypress事件处理函数 100\n6.4.4　把javascript与css结合起来 102\n6.5　dom core和html-dom 105\n6.6　小结 106\n第7章 动态创建html内容 109\n7.1　document.write()方法 110\n7.2　innerhtml属性 111\n7.3　dom提供的方法 114\n7.3.1　createelement()方法 115\n7.3.2　appendchild()方法 116\n7.3.3　createtextnode()方法 117\n7.4　重回\u201cjavascript美术馆\u201d 121\n7.4.1　insertbefore()方法 123\n7.4.2　\u201cjavascript美术馆\u201d二次改进版 127\n7.5　小结 131\n7.6　下章简介 132\n第8章 充实文档的内容 133\n8.1 不应该做的事情 133\n8.2 把\u201c不可见\u201d变成\u201c可见\u201d 134\n8.3 原始内容 135\n8.4 xhtml文档 137\n8.5 css 138\n8.6 javascript代码 139\n8.6.1 显示\u201c缩略词语表\u201d 139\n8.6.2 显示\u201c文献来源链接表\u201d 152\n8.6.3 显示\u201c快速访问键清单\u201d 158\n8.7 小结 161\n8.8 下章简介 162\n第9章 css-dom 163\n9.1 三位一体的网页 163\n9.1.1 结构层 163\n9.1.2 表示层 164\n9.1.3 行为层 164\n9.1.4 分离 165\n9.2 style属性 165\n9.2.1 样式信息的检索 167\n9.2.2 设置样式信息 172\n9.3 何时该用dom脚本去设置样式信息 174\n9.3.1 根据元素在节点树里的位置来设置样式信息 174\n9.3.2 根据某种条件来设置样式信息 178\n9.3.3 对事件做出响应 182\n9.4 classname属性 184\n9.5 小结 188\n第10章 用javascript实现动画效果 191\n10.1 何为动画 191\n10.1.1 位置 192\n10.1.2 时间 194\n10.1.3 抽象化 198\n10.2 实用的动画 205\n10.2.1 问题的提出 205\n10.2.2 问题的解决 207\n10.2.3 css 208\n10.2.4 javascript代码 210\n10.2.5 与变量的作用域有关的问题 214\n10.3 改进动画效果 216\n10.4 最后的优化 219\n10.5 小结 224\n第11章 学以致用：javascript网站设计实战 225\n11.1 案例背景介绍 225\n11.1.1 原始材料 226\n11.1.2 网站的结构 226\n11.1.3 网页的结构 227\n11.2 页面视觉效果设计 228\n11.3 css 229\n11.4 颜色 231\n11.4.1 布局 232\n11.4.2 字型 234\n11.5 xhtml文档 236\n11.6 javascript脚本 236\n11.6.1 当前页面的标识 238\n11.6.2 javascript动画 242\n11.6.3 内部浏览 247\n11.6.4 javascript美术馆 251\n11.6.5 改进表格 254\n11.6.6 改进表单 259\n11.7 小结 268\n11.8 下章简介 268\n第12章 展望dom脚本编程技术 269\n12.1 web的现状 269\n12.1.1 web浏览器 270\n12.1.2 web设计师 271\n12.1.3 三条腿的凳子 272\n12.2 ajax技术 274\n12.2.1 xmlhttprequest对象 275\n12.2.2 ajax技术的爆发 278\n12.2.3 循序渐进：如何运用ajax技术 279\n12.2.4 ajax技术的未来 281\n12.3 web应用 282\n12.4 小结 283\n附录 dom方法和属性 285","pages":"316","images":{"small":"https://img3.doubanio.com/spic/s1958902.jpg","large":"https://img3.doubanio.com/lpic/s1958902.jpg","medium":"https://img3.doubanio.com/mpic/s1958902.jpg"},"alt":"https://book.douban.com/subject/1921890/","id":"1921890","publisher":"人民邮电出版社","isbn10":"7115139210","isbn13":"9787115139214","title":"JavaScript DOM编程艺术","url":"https://api.douban.com/v2/book/1921890","alt_title":"","author_intro":"","summary":"本书讲述了JavaScript和DOM的基础知识，但重点放在DOM编程技术背后的思路和原则：预留退路、循序渐进和以用户为中心等，这些概念对于任何前端Web开发工作都非常重要。本书将这些概念贯穿在书中的所有代码示例中，使你看到用来创建图片库页面的脚本、用来创建动画效果的脚本和用来丰富页面元素呈现效果的脚本，最后结合所讲述的内容创建了一个实际的网站。\n本书适合Web设计师和开发人员阅读。","series":{"id":"28503","title":"图灵程序设计丛书·Web开发系列"},"price":"39.00元"},{"rating":{"max":10,"numRaters":1388,"average":"7.7","min":0},"subtitle":"","author":["[美]Wesley J. Chun（陳仲才）"],"pubdate":"2008-06","tags":[{"count":1393,"name":"Python","title":"Python"},{"count":642,"name":"编程","title":"编程"},{"count":283,"name":"计算机","title":"计算机"},{"count":265,"name":"程序语言","title":"程序语言"},{"count":202,"name":"python","title":"python"},{"count":190,"name":"程序设计","title":"程序设计"},{"count":173,"name":"programming","title":"programming"},{"count":112,"name":"开发","title":"开发"}],"origin_title":"Core Python Programming, 2nd Edition","image":"https://img3.doubanio.com/mpic/s3140466.jpg","binding":"平装","translator":["CPUG"],"catalog":"第1部分　Python核心\n第1章　欢迎来到Python世界\n1.1　什么是Python\n1.2　起源\n1.3　特点\n1.3.1　高级\n1.3.2　面向对象\n1.3.3　可升级\n1.3.4　可扩展\n1.3.5　可移植性\n1.3.6　易学\n1.3.7　易读\n1.3.8　易维护\n1.3.9　健壮性\n1.3.10　高效的快速原型开发工具\n1.3.11　内存管理器\n1.3.12　解释性和（字节）编译性\n1.4　下载和安装Python\n1.5　运行Python\n1.5.1　命令行上的交互式解释器\n1.5.2　从命令行启动脚本\n1.5.3　集成开发环境\n1.5.4　其他的集成开发环境和执行环境\n1.6　Python文档\n1.7　比较Python（Python与其他语言的比较）\n1.8　其他实现\n1.9　练习\n第2章　快速入门\n2.1　程序输出，print语句及\u201cHello World!\u201d\n2.2　程序输入和raw_input（）内建函数\n2.3　注释\n2.4　操作符\n2.5　变量和赋值\n2.6　数字\n2.7　字符串\n2.8　列表和元组\n2.9　字典\n2.10　代码块及缩进对齐\n2.11　if语句\n2.12　while循环\n2.13　for循环和range（）内建函数\n2.14　列表解析\n2.15　文件和内建函数open（）、file（）\n2.16　错误和异常\n2.17　函数\n2.17.1　如何定义函数\n2.17.2　如何调用函数\n2.17.3　默认参数\n2.18　类\n2.19　模块\n2.19.1　如何导入模块\n2.19.2　如何访问一个模块函数或访问一个模块变量\n2.20　实用的函数\n2.21　练习\n第3章　Python基础\n3.1　语句和语法\n3.1.1　注释（#）\n3.1.2　继续（\\）\n3.1.3　多个语句构成代码组（:）\n3.1.4　代码组由不同的缩进分隔\n3.1.5　同一行书写多个语句（;）\n3.1.6　模块\n3.2　变量赋值\n3.2.1　赋值操作符\n3.2.2　增量赋值\n3.2.3　多重赋值\n3.2.4　\u201c多元\u201d赋值\n3.3　标识符\n3.3.1　合法的Python标识符\n3.3.2　关键字\n3.3.3　内建\n3.3.4　专用下划线标识符\n3.4　基本风格指南\n3.4.1　模块结构和布局\n3.4.2　在主程序中书写测试代码\n3.5　内存管理\n3.5.1　变量定义\n3.5.2　动态类型\n3.5.3　内存分配\n3.5.4　引用计数\n3.5.5　垃圾收集\n3.6　第一个Python程序\n3.7　相关模块和开发工具\n3.8　练习\n第4章　Python对象\n4.1　Python 对象\n4.2　标准类型\n4.3　其他内建类型\n4.3.1　类型对象和type类型对象\n4.3.2　None--Python的Null对象\n4.4　内部类型\n4.4.1　代码对象\n4.4.2　帧对象\n4.4.3　跟踪记录对象\n4.4.4　切片对象\n4.4.5　省略对象\n4.4.6　XRange 对象\n4.5　标准类型操作符\n4.5.1　对象值的比较\n4.5.2　对象身份比较\n4.5.3　布尔类型\n4.6　标准类型内建函数\n4.6.1　type（）\n4.6.2　cmp（）\n4.6.3　str（）和repr（）（及``操作符）\n4.6.4　type（）和isinstance（）\n4.6.5　Python类型操作符和内建函数总结\n4.7　类型工厂函数\n4.8　标准类型的分类\n4.8.1　存储模型\n4.8.2　更新模型\n4.8.3　访问模型\n4.9　不支持的类型\n4.10　练习\n第5章　数字\n5.1　数字简介\n5.1.1　如何创建数值对象并用其赋值（数字对象）\n5.1.2　如何更新数字对象\n5.1.3　如何删除数字对象\n5.2　整型\n5.2.1　布尔型\n5.2.2　标准整型\n5.2.3　长整型\n5.2.4　整型和长整型的统一\n5.3　双精度浮点型\n5.4　复数\n5.5　操作符\n5.5.1　混合模式操作符\n5.5.2　标准类型操作符\n5.5.3　算术操作符\n5.5.4　*位操作符（只适用于整型）\n5.6　内建函数与工厂函数\n5.6.1　标准类型函数\n5.6.2　数字类型函数\n5.6.3　仅用于整型的函数\n5.7　其他数字类型\n5.7.1　布尔\u201c数\u201d\n5.7.2　十进制浮点型\n5.8　相关模块\n5.9　练习\n第6章　序列：字符串、列表和元组\n6.1　序列\n6.1.1　标准类型操作符\n6.1.2　序列类型操作符\n6.1.3　内建函数（BIF）\n6.2　字符串\n6.3　字符串和操作符\n6.3.1　标准类型操作符\n6.3.2　序列操作符切片（[]和[:]）\n6.4　只适用于字符串的操作符\n6.4.1　格式化操作符（％）\n6.4.2　字符串模板: 更简单的替代品\n6.4.3　原始字符串操作符（r/R）\n6.4.4　Unicode字符串操作符（u/U）\n6.5　内建函数\n6.5.1　标准类型函数\n6.5.2　序列类型函数\n6.5.3　字符串类型函数\n6.6　字符串内建函数\n6.7　字符串的独特特性\n6.7.1　特殊字符串和控制字符\n6.7.2　三引号\n6.7.3　字符串不变性\n6.8　Unicode\n6.8.1　术语\n6.8.2　什么是Unicode\n6.8.3　怎样使用Unicode\n6.8.4　Codec是什么\n6.8.5　编码解码\n6.8.6　把Unicode应用到实际应用中\n6.8.7　从现实中得来的教训\n6.8.8　Python的Unicode支持\n6.9　相关模块\n6.10　字符串关键点总结\n6.11　列表\n6.12　操作符\n6.12.1　标准类型操作符\n6.12.2　序列类型操作符\n6.12.3　列表类型操作符和列表解析\n6.13　内建函数\n6.13.1　标准类型函数\n6.13.2　序列类型函数\n6.13.3　列表类型内建函数\n6.14　列表类型的内建函数\n6.15　列表的特殊特性\n6.16　元组\n6.17　元组操作符和内建函数\n6.17.1　标准类型操作符、序列类型操作符和内建函数\n6.17.2　元组类型操作符和内建函数、内建方法\n6.18　元组的特殊特性\n6.18.1　不可变性给元组带来了什么影响\n6.18.2　元组也不是那么\u201c不可变\u201d\n6.18.3　默认集合类型\n6.18.4　单元素元组\n6.18.5　字典的关键字\n6.19　相关模块\n6.20　*拷贝Python对象、浅拷贝和深拷贝\n6.21　序列类型小结\n6.22　练习\n第7章　映像和集合类型\n7.1　映射类型：字典\n7.1.1　如何创建字典和给字典赋值\n7.1.2　如何访问字典中的值\n7.1.3　如何更新字典\n7.1.4　如何删除字典元素和字典\n7.2　映射类型操作符\n7.2.1　标准类型操作符\n7.2.2　映射类型操作符\n7.3　映射类型的内建函数和工厂函数\n7.3.1　标准类型函数[type（）、str（）和cmp（）]\n7.3.2　映射类型相关的函数\n7.4　映射类型内建方法\n7.5　字典的键\n7.5.1　不允许一个键对应多个值\n7.5.2　键必须是可哈希的\n7.6　集合类型\n7.6.1　如何创建集合类型和给集合赋值\n7.6.2　如何访问集合中的值\n7.6.3　如何更新集合\n7.6.4　如何删除集合中的成员和集合\n7.7　集合类型操作符\n7.7.1　标准类型操作符（所有的集合类型）\n7.7.2　集合类型操作符（所有的集合类型）\n7.7.3　集合类型操作符（仅适用于可变集合）\n7.8　内建函数\n7.8.1　标准类型函数\n7.8.2　集合类型工厂函数\n7.9　集合类型内建方法\n7.9.1　方法（所有的集合方法）\n7.9.2　方法（仅适用于可变集合）\n7.9.3　操作符和内建方法比较\n7.10　集合类型总结表\n7.11　相关模块\n7.12　练习\n第8章　条件和循环\n8.1　if语句\n8.1.1　多重条件表达式\n8.1.2　单一语句的代码块\n8.2　else语句\n8.3　elif（即else-if）语句\n8.4　条件表达式（即\u201c三元操作符\u201d）\n8.5　while语句\n8.5.1　一般语法\n8.5.2　计数循环\n8.5.3　无限循环\n8.6　for语句\n8.6.1　一般语法\n8.6.2　用于序列类型\n8.6.3　用于迭代器类型\n8.6.4　range（）内建函数\n8.6.5　xrange（） 内建函数\n8.6.6　与序列相关的内建函数\n8.7　break语句\n8.8　continue语句\n8.9　pass语句\n8.10　再谈else语句\n8.11　迭代器和iter（）函数\n8.11.1　什么是迭代器\n8.11.2　为什么要迭代器\n8.11.3　如何迭代\n8.11.4　使用迭代器\n8.11.5　可变对象和迭代器\n8.11.6　如何创建迭代器\n8.12　列表解析\n8.13　生成器表达式\n8.14　相关模块\n8.15　练习\n第9章　文件和输入输出\n9.1　文件对象\n9.2　文件内建函数（open（）和file（））\n9.2.1　工厂函数file（）\n9.2.2　通用换行符支持（UNS）\n9.3　文件内建方法\n9.3.1　输入\n9.3.2　输出\n9.3.3　文件内移动\n9.3.4　文件迭代\n9.3.5　其他\n9.3.6　文件方法杂项\n9.4　文件内建属性\n9.5　标准文件\n9.6　命令行参数\n9.7　文件系统\n9.8　文件执行\n9.9　永久存储模块\n9.9.1　pickle和marshal模块\n9.9.2　DBM风格的模块\n9.9.3　shelve模块\n9.10　相关模块\n9.11　练习\n第10章　错误和异常\n10.1　什么是异常\n10.1.1　错误\n10.1.2　异常\n10.2　Python 中的异常\n10.3　检测和处理异常\n10.3.1　try-except语句\n10.3.2　包装内建函数\n10.3.3　带有多个except的try语句\n10.3.4　处理多个异常的except语句\n10.3.5　捕获所有异常\n10.3.6　\u201c异常参数\u201d\n10.3.7　在应用使用我们封装的函数\n10.3.8　else子句\n10.3.9　finally子句\n10.3.10　try-finally语句\n10.3.11　try-except-else-finally：厨房一锅端\n10.4　上下文管理\n10.4.1　with语句\n10.4.2　*上下文管理协议\n10.5　*字符串作为异常\n10.6　触发异常\n10.7　断言\n10.8　标准异常\n10.9　*创建异常\n10.10　（现在）为什么用异常\n10.11　到底为什么要异常\n10.12　异常和sys模块\n10.13　相关模块\n10.14　练习\n第11章　函数和函数式编程\n11.1　什么是函数？\n11.1.1　函数vs过程\n11.1.2　返回值与函数类型\n11.2　调用函数\n11.2.1　函数操作符\n11.2.2　关键字参数\n11.2.3　默认参数\n11.2.4　参数组\n11.3　创建函数\n11.3.1　def语句\n11.3.2　声明与定义比较\n11.3.3　前向引用\n11.3.4　函数属性\n11.3.5　内部/内嵌函数\n11.3.6　*函数（与方法）装饰器\n11.4　传递函数\n11.5　Formal Arguments\n11.5.1　位置参数\n11.5.2　默认参数\n11.6　可变长度的参数\n11.6.1　非关键字可变长参数（元组）\n11.6.2　关键字变量参数（字典）\n11.6.3　调用带有可变长参数对象函数\n11.7　函数式编程\n11.7.1　匿名函数与lambda\n11.7.2　内建函数apply（）、filter（）、map（）、reduce（）\n11.7.3　偏函数应用\n11.8　变量作用域\n11.8.1　全局变量与局部变量\n11.8.2　globa语句\n11.8.3　作用域的数字\n11.8.4　闭包\n11.8.5　作用域和lambda\n11.8.6　变量作用域和名称空间\n11.9　*递归\n11.10　生成器\n11.10.1　简单的生成器特性\n11.10.2　加强的生成器特性\n11.11　练习\n第12章　模块\n12.1　什么是模块\n12.2　模块和文件\n12.2.1　模块名称空间\n12.2.2　搜索路径和路径搜索\n12.3　名称空间\n12.3.1　名称空间与变量作用域比较\n12.3.2　名称查找、确定作用域、覆盖\n12.3.3　无限制的名称空间\n12.4　导入模块\n12.4.1　import语句\n12.4.2　from-import语句\n12.4.3　多行导入\n12.4.4　扩展的import语句（as）\n12.5　模块导入的特性\n12.5.1　载入时执行模块\n12.5.2　导入（import）和加载（load）\n12.5.3　导入到当前名称空间的名称\n12.5.4　被导入到导入者作用域的名字\n12.5.5　关于__future__\n12.5.6　警告框架\n12.5.7　从ZIP文件中导入模块\n12.5.8　\u201c新的\u201d导入钩子\n12.6　模块内建函数\n12.6.1　__import__（）\n12.6.2　globals（）和locals（）\n12.6.3　reload（）\n12.7　包\n12.7.1　目录结构\n12.7.2　使用from-import导入包\n12.8　模块的其他特性\n12.8.1　自动载入的模块\n12.8.2　阻止属性导入\n12.8.3　不区分大小的导入\n12.8.4　源代码编码\n12.8.5　导入循环\n12.8.6　模块执行\n12.9　相关模块\n12.10　练习\n第13章　面向对象编程\n13.1　引言\n13.2　面向对象编程\n13.2.1　面向对象设计与面向对象编程的关系\n13.2.2　现实中的问题\n13.2.3　*常用术语\n13.3　类\n13.3.1　创建类\n13.3.2　声明与定义\n13.4　类属性\n13.4.1　类的数据属性\n13.4.2　Methods\n13.4.3　决定类的属性\n13.4.4　特殊的类属性\n13.5　实例\n13.5.1　初始化：通过调用类对象来创建实例\n13.5.2　__init__（）\u201c构造器\u201d方法\n13.5.3　__new__（）\u201c构造器\u201d方法\n13.5.4　__del__（）\u201c解构器\u201d方法\n13.6　实例属性\n13.6.1　\u201c实例化\u201d实例属性（或创建一个更好的构造器）\n13.6.2　查看实例属性\n13.6.3　特殊的实例属性\n13.6.4　建类型属性\n13.6.5　实例属性vs类属性\n13.7　绑定和方法调用\n13.7.1　调用绑定方法\n13.7.2　调用非绑定方法\n13.8　静态方法和类方法\n13.8.1　staticmethod（）和classmethod（）内建函数\n13.8.2　使用函数修饰符\n13.9　组合\n13.10　子类和派生\n13.11　继承\n13.11.1　__bases__类属性\n13.11.2　通过继承覆盖方法\n13.11.3　从标准类型派生\n13.11.4　多重继承\n13.12　类、实例和其他对象的内建函数\n13.12.1　issubclass（）\n13.12.2　isinstance（）\n13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）\n13.12.4　dir（）\n13.12.5　super（）\n13.12.6　vars（）\n13.13　用特殊方法定制类\n13.13.1　简单定制（RoundFloat2）\n13.13.2　数值定制（Time60）\n13.13.3　迭代器（RandSeq和AnyIter）\n13.13.4　*多类型定制（NumStr）\n13.14　私有化\n13.15　*授权\n13.15.1　包装\n13.15.2　实现授权\n13.16　新式类的高级特性（Python 2.2+）\n13.16.1　新式类的通用特性\n13.16.2　__slots__类属性\n13.16.3　__getattribute__（）特殊方法\n13.16.4　描述符\n13.16.5　元类和__metaclass__\n13.17　相关模块和文档\n13.18　练习\n第14章　执行环境\n14.1　可调用对象\n14.1.1　函数\n14.1.2　方法\n14.1.3　类\n14.1.4　类的实例\n14.2　代码对象\n14.3　可执行的对象声明和内建函数\n14.3.1　callable（）\n14.3.2　compile（）\n14.3.3　eval（）\n14.3.4　exec\n14.3.5　input（）\n14.3.6　使用Python在运行时生成和执行Python代码\n14.4　执行其他（Python）程序\n14.4.1　导入\n14.4.2　execfile（）\n14.4.3　将模块作为脚本执行\n14.5　执行其他（非Python）程序\n14.5.1　os.system（）\n14.5.2　os.popen（）\n14.5.3　os.fork（）、os.exec*（）、os.wait*（）\n14.5.4　os.spawn*（）\n14.5.5　subprocess 模块\n14.5.6　相关函数\n14.6　受限执行\n14.7　结束执行\n14.7.1　sys.exit（） and SystemExit\n14.7.2　sys.exitfunc（）\n14.7.3　os._exit（） 函数\n14.7.4　os.kill（） Function\n14.8　各种操作系统接口\n14.9　相关模块\n14.10　练习\n第2部分　高级主题\n第15章　正则表达式\n15.1　引言/动机\n15.2　正则表达式使用的特殊符号和字符\n15.2.1　用管道符号（|）匹配多个正则表达式模式\n15.2.2　匹配任意一个单个的字符（.）\n15.2.3　从字符串的开头或结尾或单词边界开始匹配（^/$ /\\b /\\B ）\n15.2.4　创建字符类（[]）\n15.2.5　指定范围（-）和否定（^）\n15.2.6　使用闭包操作符（*，+，?，{}）实现多次出现/重复匹配\n15.2.7　特殊字符表示、字符集\n15.2.8　用圆括号（（））组建组\n15.3　正则表达式和Python语言\n15.3.1　re模块：核心函数和方法\n15.3.2　使用compile（）编译正则表达式\n15.3.3　匹配对象和group（）、groups（）方法\n15.3.4　用match（）匹配字符串\n15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）\n15.3.6　匹配多个字符串（|）\n15.3.7　匹配任意单个字符（.）\n15.3.8　创建字符集合（[]）\n15.3.9　重复、特殊字符和子组\n15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配\n15.3.11　用findall（）找到每个出现的匹配部分\n15.3.12　用sub（）（和subn（））进行搜索和替换\n15.3.13　用split（）分割（分隔模式）\n15.4　正则表达式示例\n15.4.1　匹配一个字符串\n15.4.2　搜索与匹配的比较，\u201c贪婪\u201d匹配\n15.5　练习\n第16章　网络编程\n16.1　引言\n16.1.1　什么是客户端/服务器架构\n16.1.2　客户端/服务器网络编程\n16.2　套接字：通信端点\n16.2.1　什么是套接字\n16.2.2　套接字地址：主机与端口\n16.2.3　面向连接与无连接\n16.3　Python中的网络编程\n16.3.1　socket（）模块函数\n16.3.2　套接字对象（内建）方法\n16.3.3　创建一个TCP服务器\n16.3.4　创建TCP客户端\n16.3.5　运行我们的客户端与TCP服务器\n16.3.6　创建一个UDP服务器\n16.3.7　创建一个UDP客户端\n16.3.8　执行UDP服务器和客户端\n16.3.9　Socket模块属性\n16.4　*SocketServer模块\n16.4.1　创建一个SocketServerTCP服务器\n16.4.2　创建SocketServerTCP客户端\n16.4.3　执行TCP服务器和客户端\n16.5　Twisted框架介绍\n16.5.1　创建一个Twisted Reactor TCP服务器\n16.5.2　创建一个Twisted Reactor TCP客户端\n16.5.3　执行TCP服务器和客户端\n16.6　相关模块\n16.7　练习\n第17章　网络客户端编程\n17.1　什么是因特网客户端\n17.2　文件传输\n17.2.1　文件传输网际协议\n17.2.2　文件传输协议（FTP）\n17.2.3　Python和FTP\n17.2.4　ftplib.FTP类方法\n17.2.5　交互式FTP示例\n17.2.6　客户端FTP程序举例\n17.2.7　FTP的其他方面\n17.3　网络新闻\n17.3.1　Usenet与新闻组\n17.3.2　网络新闻传输协议（NNTP）\n17.3.3　Python和NNTP\n17.3.4　nntplib.NNTP类方法\n17.3.5　交互式NNTP举例\n17.3.6　客户端程序NNTP举例\n17.3.7　NNTP的其他方面\n17.4　电子邮件\n17.4.1　电子邮件系统组件和协议\n17.4.2　发送电子邮件\n17.4.3　Python和SMTP\n17.4.4　smtplib.SMTP类方法\n17.4.5　交互式SMTP示例\n17.4.6　SMTP的其他方面\n17.4.7　接收电子邮件\n17.4.8　POP和IMAP\n17.4.9　Python和POP3\n17.4.10　交互式POP3举例\n17.4.11　poplib.POP3类方法\n17.4.12　客户端程序SMTP和POP3举例\n17.5　相关模块\n17.5.1　电子邮件\n17.5.2　其他网络协议\n17.6　练习\n第18章　多线程编程\n18.1　引言/动机\n18.2　线程和进程\n18.2.1　什么是进程\n18.2.2　什么是线程\n18.3　Python、线程和全局解释器锁\n18.3.1　全局解释器锁（GIL）\n18.3.2　退出线程\n18.3.3　在Python中使用线程\n18.3.4　没有线程支持的情况\n18.3.5　Python的threading模块\n18.4　thread模块\n18.5　threading模块\n18.5.1　Thread类\n18.5.2　斐波那契、阶乘和累加和\n18.5.3　threading模块中的其他函数\n18.5.4　生产者-消费者问题和Queue模块\n18.6　相关模块\n18.7　练习\n第19章　图形用户界面编程\n19.1　简介\n19.1.1　什么是Tcl、Tk和Tkinter\n19.1.2　安装和使用Tkinter　533\n19.1.3　客户端/服务器架构　534\n19.2　Tkinter与Python编程　534\n19.2.1　Tkinter模块：把Tk引入你的程序\n19.2.2　GUI程序开发简介\n19.2.3　顶层窗口：Tkinter.Tk（）\n19.2.4　Tk组件\n19.3　Tkinter举例\n19.3.1　标签组件\n19.3.2　按钮组件\n19.3.3　标签和按钮组件\n19.3.4　标签、按钮和进度条组件\n19.3.5　偏函数应用举例\n19.3.6　中级Tkinter范例\n19.4　其他GUI简介\n19.4.1　Tk Interface eXtensions （Tix）\n19.4.2　Python MegaWidgets （PMW）\n19.4.3　wxWidgets和wxPython\n19.4.4　GTK+和PyGTK\n19.5　相关模块和其他GUI\n19.6　练习\n第20章　Web编程\n20.1　介绍\n20.1.1　Web应用：客户端/服务器计算\n20.1.2　因特网\n20.2　使用Python进行Web应用：创建一个简单的Web客户端\n20.2.1　统一资源定位符\n20.2.2　urlparse模块\n20.2.3　urllib模块\n20.2.4　urllib2模块\n20.3　高级Web客户端\n20.4　CGI：帮助Web服务器处理客户端数据\n20.4.1　CGI介绍\n20.4.2　CGI应用程序\n20.4.3　cgi模块\n20.5　建立CGI应用程序\n20.5.1　建立Web服务器\n20.5.2　建立表单页\n20.5.3　生成结果页\n20.5.4　生成表单和结果页面\n20.5.5　全面交互的Web站点\n20.6　在CGI中使用Unicode编码\n20.7　高级CGI\n20.7.1　Mulitipart表单提交和文件的上传\n20.7.2　多值字段\n20.7.3　cookie\n20.7.4　使用高级CGI\n20.8　Web（HTTP）服务器\n20.9　相关模块\n20.10　练习\n第21章　数据库编程\n21.1　介绍\n21.1.1　持久存储\n21.1.2　基本的数据库操作和SQL语言\n21.1.3　数据库和Python\n21.2　Python数据库应用程序程序员接口（DB-API）\n21.2.1　模块属性\n21.2.2　连接对象\n21.2.3　游标对象\n21.2.4　类型对象和构造器\n21.2.5　关系数据库\n21.2.6　数据库和Python：接口程序\n21.2.7　使用数据库接口程序举例\n21.3　对象-关系管理器（ORM）\n21.3.1　考虑对象，而不是SQL\n21.3.2　Python和ORM\n21.3.3　雇员数据库举例\n21.3.4　总结\n21.4　相关模块\n21.5　练习\n第22章　扩展Python　623\n22.1　引言/动机\n22.1.1　什么是扩展\n22.1.2　为什么要扩展Python\n22.2　创建Python扩展\n22.2.1　创建您的应用程序代码\n22.2.2　用样板来包装你的代码\n22.2.3　编译\n22.2.4　导入和测试\n22.2.5　引用计数\n22.2.6　线程和全局解释器锁（GIL）\n22.3　相关话题\n22.4　练习\n第23章　其他话题\n23.1　Web服务\n23.2　用Win32的COM来操作微软Office\n23.2.1　客户端COM编程\n23.2.2 微软Excel\n23.2.3　微软Word　第1部分　Python核心\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习","pages":"654","images":{"small":"https://img3.doubanio.com/spic/s3140466.jpg","large":"https://img3.doubanio.com/lpic/s3140466.jpg","medium":"https://img3.doubanio.com/mpic/s3140466.jpg"},"alt":"https://book.douban.com/subject/3112503/","id":"3112503","publisher":"人民邮电出版社","isbn10":"711517850X","isbn13":"9787115178503","title":"Python核心编程（第二版）","url":"https://api.douban.com/v2/book/3112503","alt_title":"Core Python Programming, 2nd Edition","author_intro":"","summary":"本书是Python开发者的完全指南\u2014\u2014针对 Python 2.5全面升级\n·学习专业的Python风格、最佳实践和好的编程习惯；\n·加强对Python对象、内存模型和Python面向对象特性的深入理解；\n·构建更有效的Web、CGI、互联网、网络和其他客户端/服务器架构应用程序及软件；\n·学习如何使用Python中的Tkinter和其他工具来开发自己的GUI应用程序及软件；\n·通过用C等语言编写扩展来提升Python应用程序的性能，或者通过使用多线程增强I/0相关的应用程序的能力；\n·学习Python中有关数据库的API，以及如何在Python中使用各种不同的数据库系统，包括MySQL、Postgres和 SQLite。","price":"89.00元"},{"rating":{"max":10,"numRaters":1450,"average":"7.1","min":0},"subtitle":"","author":["池建强"],"pubdate":"2014-2-1","tags":[{"count":381,"name":"mac","title":"mac"},{"count":345,"name":"计算机","title":"计算机"},{"count":232,"name":"池建强","title":"池建强"},{"count":218,"name":"杂文","title":"杂文"},{"count":182,"name":"互联网","title":"互联网"},{"count":176,"name":"Mac","title":"Mac"},{"count":158,"name":"编程","title":"编程"},{"count":115,"name":"IT技术","title":"IT技术"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s28409836.jpg","binding":"平装","translator":[],"catalog":"写在前面的话\n技术写作与减熵\n但行好事，莫问前程\n生命中遇见的每一本书，都不是偶然\n开篇：为何而写\nMac\nMacintosh 的命名\n1984，Mac 诞生\nMacintosh 演化史\n说说我和Mac\n品评OS X Mavericks--唯快不破\n免费的代价--从OS X 免费谈起\n选择Mac\n开始使用Mac\n非同凡想\n怀念2007\n年轻时的梦想还在吗\n苹果的语言\nMac Tips\n程序员与编程\n并发的错觉\n程序员的性格\n程序员如何提高英语阅读水平\n普通人之殇\n趣谈个人建站\n人生元编程\n如何提问\n如何学习一门编程语言\n神奇的程序员--王小波\nLinux 的文件系统王国\n科技与人文\n不要做一个Hater\n沉默的坚持和沉没的成本\n缅怀那些沉没的项目\n锤子和钉子\n读书日谈书\n付费阅读\n技术成长\n克隆高手\n老兵不死，只能自我提升\n没文化有人文\n明天的科技\n你有多少时间\n自由软件\n允许吹牛\n用好自己的份额\n也无风雨也无晴\n写作与编程\n奇特的一生\n是旅行还是长跑\n西塘古色\n《晓说》不小\n遗失的访谈--岁月无声\n怎能忘了西游\n重读黑客与画家\n人物\n传统的黑客--史蒂夫·沃兹\n从汇编到太空--保罗·艾伦\n敬畏之心\n设计巨匠--乔纳森·艾维\n工具\nVim\n神兵利器--Alfred\n终极Shell\n职场\n留不住的人才\n薪水几何\n顾得上就问，是为\u201c顾问\u201d也\n跟着老大去跳槽\n一生要面试多少回\n去创业还是继续编程\n去公司上班还是独自在家\n独自在家续篇兼答读者问","pages":"316","images":{"small":"https://img3.doubanio.com/spic/s28409836.jpg","large":"https://img3.doubanio.com/lpic/s28409836.jpg","medium":"https://img3.doubanio.com/mpic/s28409836.jpg"},"alt":"https://book.douban.com/subject/25826578/","id":"25826578","publisher":"人民邮电出版社","isbn10":"7115342237","isbn13":"9787115342232","title":"MacTalk 人生元编程","url":"https://api.douban.com/v2/book/25826578","alt_title":"","author_intro":"池建强，70后程序员，Blogger，微信平台MacTalk作者。先后任职于洪恩软件和用友集团，从事互联网和企业应用软件研发，目前担任瑞友科技IT应用研究院技术负责人。\n热爱技术和编码工作，Apple和Google产品重度用户，分享技术，坚持梦想。","summary":"《MacTalk·人生元编程》是一本随笔文集，主要内容来自作者的微信公众平台\u201cMacTalk By 池建强\u201d。本书撰写于2013年，书中时间线却不止于此。作者以一个70 后程序员的笔触，立于Mac 之上，讲述技术与人文的故事，有历史，有明天，有技术，有人生。70 多篇文章划分为六大主题：Mac、程序员与编程、科技与人文、人物、工具、职场。篇篇独立成文，可拆可合，随时阅读。\n此外，作者还对原来散落在各篇文章中的Mac 技巧进行了统一的整理和规划，形成130 个Mac Tips，通过阅读这些技巧，读者既可以了解Mac，增长知识，又能够提高工作效率。\n本书行文采用了一种技术和人生感悟相结合的风格，起于Mac 却不止Mac，文风幽默又能笔底见风雷。王小波说，\u201c每一本书都应该有趣，对于一些书来说，有趣是它存在的理由；对于另一些书，有趣是它应该达到的标准\u201d。本书就是一本达到了有趣标准的技术书，它不仅适合Mac 用户阅读，更值得所有技术人员随时翻阅。","price":"45"},{"rating":{"max":10,"numRaters":313,"average":"8.6","min":0},"subtitle":"","author":["[美] 桑德Warren Sande","Carter Sande"],"pubdate":"2010-11","tags":[{"count":564,"name":"编程","title":"编程"},{"count":465,"name":"python","title":"python"},{"count":214,"name":"儿童教育","title":"儿童教育"},{"count":204,"name":"计算机","title":"计算机"},{"count":145,"name":"程序设计","title":"程序设计"},{"count":108,"name":"Python","title":"Python"},{"count":85,"name":"Programming","title":"Programming"},{"count":74,"name":"教育","title":"教育"}],"origin_title":"Hello World！Computer Programming for Kids and Other Beginners","image":"https://img3.doubanio.com/mpic/s4518521.jpg","binding":"平装","translator":["苏金国","姚曜 等"],"catalog":"第1章 出发吧    1\n1.1 安装Python     1\n1.2 从IDLE启动Python   2\n1.3 来点指令吧     3\n1.4 与Python交互   5\n1.5 该编程了     7\n1.6 运行你的第一个程序   8\n1.7 如果出问题     9\n1.8 你的第二个程序   11\n第2章 记住内存和变量  14\n2.1 输入、处理和输出   14\n2.2 名字     16\n2.3 名字里是什么   20\n2.4 数字和字符串   21\n2.5 它们有多\u201c可变\u201d   22\n2.6 全新的我     23\n第3章 基本数学运算  　26\n3.1 四大基本运算  　 26\n3.2 操作符     　28\n3.3 运算顺序     29\n3.4 另外两个操作符   30\n3.5 非常大和非常小   33\n第4章 数据的类型  　38\n4.1 改变类型     38\n4.2 得到更多信息：type() 　41\n4.3 类型转换错误   42\n4.4 使用类型转换   42\n第5章 输入    44\n5.1 raw_input()   44\n5.2 Print命令和逗号   45\n5.3 输入数字     47\n5.4 来自互联网的输入   49\n第6章 GUI\u2014\u2014图形用户界面　　52\n6.1 什么是GUI     52\n6.2 第一个GUI     53\n6.3 GUI输入     54\n6.4 选择你的口味   55\n6.5 再看猜数游戏   59\n6.6 其他GUI组件   60\n第7章 判断再判断  62\n7.1 测试，测试     62\n7.2 缩进     64\n7.3 是不是有问题   65\n7.4 其他类型的测试   66\n7.5 如果测试为假会怎么样 67\n7.6 测试多个条件   69\n7.7 使用and     69\n7.8 使用or     70\n7.9 使用not     70\n第8章 转圈圈    74\n8.1 计数循环     75\n8.2 使用计数循环   77\n8.3 一条捷径\u2014\u2014range() 　　78\n8.4 风格问题\u2014\u2014循环变量名　 80\n8.5 按步长计数     82\n8.6 没有数字的计数   84\n8.7 关于这个问题   84\n8.8  跳出循环\u2014\u2014break和continue    85\n第9章 全都为了你\u2014\u2014注释　　89\n9.1 增加注释     89\n9.2 单行注释     90\n9.3 行末注释     90\n9.4 多行注释     90\n9.5 注释风格     91\n9.6 注释掉     92\n第10章 游戏时间到了  94\n第11章 嵌套与可变循环  99\n11.1 嵌套循环     99\n11.2 可变循环     101\n11.3 可变嵌套循环   102\n11.4 更多可变嵌套循环   103\n11.5 使用嵌套循环   105\n第12章 收集起来\u2014\u2014列表　　112\n12.1 什么是列表   112\n12.2 创建列表     113\n12.3 向列表增加元素   113\n12.4 这个点是什么   114\n12.5 列表可以包含任何内容　 114\n12.6 从列表获取元素  　 115\n12.7 列表\u201c分片\u201d   116\n12.8 修改元素     118\n12.9  向列表增加元素的其他方法     118\n12.10 从列表删除元素   120\n12.11 搜索列表   121\n12.12 循环处理列表   122\n12.13 列表排序   123\n12.14 可改变和不可改变 　126\n12.15 双重列表：数据表　 126\n第13章 函数    131\n13.1 函数\u2014\u2014积木   131\n13.2 调用函数     133\n13.3 向函数传递参数   134\n13.4 有多个参数的函数   137\n13.5 返回值的函数   139\n13.6 变量作用域   140\n13.7 强制为全局   143\n13.8 关于变量命名的一点建议 　144\n第14章 对象   　146\n14.1 真实世界中的对象   146\n14.2 Python中的对象  　147\n14.3 对象 = 属性+ 方法   148\n14.4 这个点是什么   148\n14.5 创建对象     149\n14.6 一个示例类\u2014\u2014HotDog 154\n14.7 隐藏数据     159\n14.8 多态和继承   159\n14.9 未雨绸缪     161\n第15章 模块    164\n15.1 什么是模块   164\n15.2 为什么使用模块   　164\n15.3 积木桶    　165\n15.4 如何创建模块   165\n15.5 如何使用模块   165\n15.6 命名空间     167\n15.7 标准模块     170\n第16章 图形    174\n16.1 寻求帮助\u2014\u2014Pygame　 174\n16.2 Pygame窗口   175\n16.3 在窗口中画图   178\n16.4 单个像素     186\n16.5 图像     190\n16.6 动起来   　192\n16.7 动画     193\n16.8 更流畅的动画   194\n16.9 让球反弹     195\n16.10 让球翻转   198\n第17章 动画精灵和碰撞检测　　201\n17.1 动画精灵     201\n17.2 嘣! 碰撞检测   207\n17.3 统计时间   　211\n第18章 一种新的输入\u2014\u2014事件　　216\n18.1 事件     216\n18.2 键盘事件     218\n18.3 鼠标事件     222\n18.4 定时器事件   224\n18.5 另一个游戏PyPong　 226\n第19章 声音   　238\n19.1  从Pygame寻求更多帮助\u2014\u2014mixer   238\n19.2 制造声音与播放声音 239\n19.3 播放声音     239\n19.4 控制音量     242\n19.5 重复音乐     244\n19.6 为PyPong增加声音 244\n19.7 更多声音     245\n19.8 为PyPong增加音乐 249\n第20章 更 多 GUI  253\n20.1 使用PythonCard   .253\n20.2 组件     254\n20.3 让GUI做点事情   256\n20.4 事件处理器的返回   258\n20.5 移动按钮     259\n20.6 更多有用的GUI   259\n20.7 TempGUI     259\n20.8 菜单上是什么   264\n第21章 打印格式化与字符串　　271\n21.1 换行     272\n21.2 水平间隔\u2014\u2014制表符 　　273\n21.3 在字符串中插入变量 　　275\n21.4 数字格式化   　276\n21.5 更多字符串处理  　280\n第22章 文件输入与输出　　287\n22.1 什么是文件   287\n22.2 文件名   　288\n22.3 文件位置     289\n22.4 打开文件     292\n22.5 读文件   　293\n22.6 文本文件和二进制文件　 295\n22.7 写文件     　296\n22.8 在文件中保存内容：pickle　 300\n22.9  又到了游戏时间\u2014\u2014Hangman     301\n第23章 碰运气\u2014\u2014随机性　　310\n23.1 什么是随机性   310\n23.2 掷骰子     311\n23.3 创建一副牌  　 316\n23.4 Crazy Eights 　  320\n第24章 计算机仿真　  333\n24.1 真实世界建模   333\n24.2 Lunar Lander   334\n24.3 跟踪时间     339\n24.4 时间对象     340\n24.5 把时间保存到文件   343\n24.6 电子宠物     345\n第25章 接下来呢  354\n25.1 一般编程     354\n25.2 Python     355\n25.3 游戏编程与Pygame　　355\n25.4 其他Python模块   356\n25.5 回顾     358\n附录 变量命名规则 　 359\n自测题答案  　  361","ebook_url":"https://read.douban.com/ebook/1003628/","pages":"388","images":{"small":"https://img3.doubanio.com/spic/s4518521.jpg","large":"https://img3.doubanio.com/lpic/s4518521.jpg","medium":"https://img3.doubanio.com/mpic/s4518521.jpg"},"alt":"https://book.douban.com/subject/5338024/","id":"5338024","publisher":"人民邮电出版社","isbn10":"7115239967","isbn13":"9787115239969","title":"与孩子一起学编程","url":"https://api.douban.com/v2/book/5338024","alt_title":"Hello World！Computer Programming for Kids and Other Beginners","author_intro":"Warren Sande    毕业于加拿大里贾那大学电气工程系。一直在面向计算机初学者教授软件基础课程，编写过大量广受欢迎的技术文档。\nCarter Sande    Warren之子，一个聪明、热情、好奇心强、喜欢思考问题的小男孩，热爱计算机，喜欢弹钢琴和玩超级玛丽。很小的时候就开始跟着父亲玩编程。","summary":"一本老少咸宜的编程入门奇书！一册在手，你完全可以带着自己的孩子，跟随Sande父子组合在轻松的氛围中熟悉那些编程概念，如内存、循环、输入和输出、数据结构和图形用户界面等。这些知识一点儿也不高深，听起来备感亲切，书中言语幽默风趣而不失真义，让学习过程充满乐趣。细心的作者还配上了孩子们都喜欢的可爱漫画和经过运行测试的程序示例，教你用最易编写和最易理解的Python语言，写出你梦想中的游戏程序。\n\u201cHello, World!我来了！\u201d编程乐趣无穷，起点就在脚下，请引导你的孩子走进这奇妙的世界。无论是中小学生还是其他初学者，都可以跟随本书学习Python编程，并过渡到任何其他语言，重要的是你将学会思考问题和解决问题的方法。","ebook_price":"30.00","series":{"id":"660","title":"图灵程序设计丛书"},"price":"65.00元"},{"rating":{"max":10,"numRaters":536,"average":"8.7","min":0},"subtitle":"","author":["(美)Jon Bentley"],"pubdate":"2008 年10月","tags":[{"count":353,"name":"编程","title":"编程"},{"count":336,"name":"算法","title":"算法"},{"count":164,"name":"编程珠玑","title":"编程珠玑"},{"count":160,"name":"程序设计","title":"程序设计"},{"count":131,"name":"计算机","title":"计算机"},{"count":79,"name":"programming","title":"programming"},{"count":76,"name":"经典","title":"经典"},{"count":73,"name":"算法与数据结构","title":"算法与数据结构"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s3304504.jpg","binding":"平装","translator":["钱丽艳;刘田"],"catalog":"","pages":"186","images":{"small":"https://img3.doubanio.com/spic/s3304504.jpg","large":"https://img3.doubanio.com/lpic/s3304504.jpg","medium":"https://img3.doubanio.com/mpic/s3304504.jpg"},"alt":"https://book.douban.com/subject/3234692/","id":"3234692","publisher":"人民邮电出版社","isbn10":"711517606X","isbn13":"9787115176066","title":"编程珠玑II","url":"https://api.douban.com/v2/book/3234692","alt_title":"","author_intro":"Jon Bentley，世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基\u2014梅隆大学(1976\u20141982)、贝尔实验室(1982\u20142001)和Avaya实验室(2001年至今)。在卡内基\u2014梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr．Dobb's程序设计卓越奖。.","summary":"本书是计算机科学方面的经典名著《编程珠玑》的姊妹篇，讲述了对于程序员有共性的知识。书中涵盖了程序员操纵程序的技术、程序员取舍的技巧、输入和输出设计以及算法示例，这些内容结合成一个有机的整体，如一串串珠玑展示给程序员。本书适合各级程序员阅读参考。...\n【媒体评论】\n\u201c《编程珠玑》第1版是对我职业生涯早期影响最大的书之一，其中的许多真知灼见多年之后仍然使我受益匪浅。Jon在第2版中对素材进行了大量更新，许多新内容让我耳目一新。\u201d.\n\u2014\u2014Steve McConnell，软件工程大师，IEEE Software前主编，《代码大全》作者\n\u201c对每一位遇到的程序员，我都会毫不迟疑地建议他阅读并不断重读这部经典之作。\u201d...\n\u2014\u2014Slashdot","series":{"id":"660","title":"图灵程序设计丛书"},"price":"39.00元"},{"rating":{"max":10,"numRaters":271,"average":"7.2","min":0},"subtitle":"与27位编程语言创始人对话","author":["Federico Biancuzzi","Shane Warden"],"pubdate":"2010-04","tags":[{"count":327,"name":"编程","title":"编程"},{"count":152,"name":"程序设计","title":"程序设计"},{"count":125,"name":"计算机","title":"计算机"},{"count":96,"name":"思维","title":"思维"},{"count":83,"name":"programming","title":"programming"},{"count":64,"name":"软件开发","title":"软件开发"},{"count":59,"name":"编程语言与系统","title":"编程语言与系统"},{"count":54,"name":"O'Reilly","title":"O'Reilly"}],"origin_title":"Masterminds of Programming","image":"https://img3.doubanio.com/mpic/s4305983.jpg","binding":"平裝","translator":["闫怀志"],"catalog":"推荐序\n前言\n1 C++\nBjarne Stroustrup\n1.1 设计决策\n1.2 使用语言\n1.3 OOP和并发\n1.4 关于未来\n1.5 有关教学\n2 Python\nGuido van Rossum\n2.1 Python方式\n2.2 优秀的程序员\n2.3 多种Python\n2.4 权宜之计和经验\n3 APL\nAdin Falkoff\n3.1 纸笔方式\n3.2 基本原理\n3.3 并行\n3.4 遗留\n4 Forth\nChuck Moore\n4.1 Forth语言与语言设计\n4.2 硬件\n4.3 应用程序设计\n5 BASIC\nTom Kurtz\n5.1 BASIC背后的目标\n5.2 编译器设计\n5.3 语言和编程实践\n5.4 语言设计\n5.5 工作目标\n6 AWK\nAl Aho\n6.1 算法生命周期\n6.2 语言设计\n6.3 Unix及其文化\n6.4 文档的作用\n6.5 计算机科学\n6.6 培育小语言\n6.7 设计一种新语言\n6.8 遗留文化\n6.9 变革性技术\n6.10 改变世界的\u201c位\u201d\n6.11 理论和实践\n6.12 等待突破\n6.13 通过实例来编程\n7 Lua\nLuiz Henrique de Figueiredo and Roberto Ierusalimschy\n7.1 脚本的功能\n7.2 经验\n7.3 语言设计\n8 Haskell\nSimon Peyton Jones, Paul Hudak, Philip Wadler, and John Hughes\n8.1 功能性团队\n8.2 函数式编程之路\n8.3 Haskell语言\n8.4 传播（函数式）教育\n8.5 形式体系和发展\n9 ML\nRobin Milner\n9.1 可靠性定理\n9.2 意义理论（译注）\n9.3 超越信息学\n10 SQL\nDon Chamberlin\n10.1 一篇开创性的有重大影响的根本性的论文\n10.2 语言\n10.3 反馈和演进\n10.4 XQuery和XML\n11 Objective-C\nBrad Cox and Tom Love\n11.1 Objective-C工程\n11.2 培育一种语言\n11.3 教育和培训\n11.4 项目管理和遗留软件\n11.5 Objective-C和其它语言\n11.6 组件、沙子和砖\n11.7 作为经济现象的质量\n11.8 教育\n12 Java\nJames Gosling\n12.1 功能或者简单性\n12.2 品味的问题\n12.3 并发性\n12.4 设计一种语言\n12.5 反馈循环\n13 C#\nAnders Hejlsberg\n13.1 语言和设计\n13.2 培育一种语言\n13.3 C# 238\n13.4 计算机科学的未来\n14 UML\nIvar Jacobson, James Rumbaugh, and Grady Booch\n14.1 学习和教学\n14.2 人们的角色\n14.3 UML\n14.4 知识\n14.5 作好变革准备\n14.6 使用UML\n14.7 层和语言\n14.8 一点可复用性\n14.9 对称关系\n14.10 UML\n14.11 语言设计\n14.12 培训开发者\n14.13 创新、改进和模式\n15 Perl\nLarry Wall\n15.1 革命性的语言\n15.2 语言\n15.3 社区\n15.4 改进和革命\n16 PostScript\nCharles Geschke and John Warnock\n16.1 为永恒而设计\n16.2 研究和教育\n16.3 长寿命接口\n16.4 标准愿望\n17 Eiffel\nBertrand Meyer\n17.1 一个充满灵感的下午\n17.2 可复用性和泛型\n17.3 校对语言\n17.4 管理成长和演进\n后记\n受访嘉宾\n索引","pages":"400","images":{"small":"https://img3.doubanio.com/spic/s4305983.jpg","large":"https://img3.doubanio.com/lpic/s4305983.jpg","medium":"https://img3.doubanio.com/mpic/s4305983.jpg"},"alt":"https://book.douban.com/subject/4719230/","id":"4719230","publisher":"电子工业出版社","isbn10":"7121104989","isbn13":"9787121104985","title":"编程之魂","url":"https://api.douban.com/v2/book/4719230","alt_title":"Masterminds of Programming","author_intro":"","summary":"本书是27位杰出的设计师与你分享他们的智慧和经验。书中以问答方式告诉为什么要创建某种编程语言、它在技术上如何开发、如何教授和学习，以及它如何顺应时代发展等。你会发现构建成功编程语言所需的思想和步骤，它广受欢迎的原因，以及如何处理程序员常见的问题。因此，如果你想深入学习设计成功编程语言的思想，本书会对你大有帮助。","price":"59.80元"},{"rating":{"max":10,"numRaters":332,"average":"8.7","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":495,"name":"网络编程","title":"网络编程"},{"count":435,"name":"C++","title":"C++"},{"count":425,"name":"Linux","title":"Linux"},{"count":360,"name":"多线程","title":"多线程"},{"count":106,"name":"编程","title":"编程"},{"count":104,"name":"计算机","title":"计算机"},{"count":63,"name":"Networks","title":"Networks"},{"count":60,"name":"Programming","title":"Programming"}],"origin_title":"","image":"https://img1.doubanio.com/mpic/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 \u201c多线程服务器的适用场合\u201d例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 \u201c串并转换\u201d连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 \u201c能随时重启进程\u201d作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现\u201c重排数组，让奇数位于偶数前面\u201d . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com/spic/s24522799.jpg","large":"https://img1.doubanio.com/lpic/s24522799.jpg","medium":"https://img1.doubanio.com/mpic/s24522799.jpg"},"alt":"https://book.douban.com/subject/20471211/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https://api.douban.com/v2/book/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"},{"rating":{"max":10,"numRaters":472,"average":"9.5","min":0},"subtitle":"","author":["[意] Paolo Perrotta"],"pubdate":"2012-1-10","tags":[{"count":724,"name":"Ruby","title":"Ruby"},{"count":395,"name":"元编程","title":"元编程"},{"count":210,"name":"编程","title":"编程"},{"count":133,"name":"动态语言","title":"动态语言"},{"count":112,"name":"计算机","title":"计算机"},{"count":98,"name":"Programming","title":"Programming"},{"count":90,"name":"ruby","title":"ruby"},{"count":80,"name":"程序设计","title":"程序设计"}],"origin_title":"Metaprogramming Ruby","image":"https://img1.doubanio.com/mpic/s7014167.jpg","binding":"平装","translator":["廖志刚","陈睿杰"],"catalog":"目录\n前言 vii\n致谢 ix\n引言 xi\n\u201c元\u201d这个字眼 xii\n关于本书 xix\n关于你 xxii\n第1部分 Ruby元编程 1\n第1章 星期一：对象模型 3\n1.1 跟Bill在一起的星期一 3\n1.2 打开类 4\n1.3 类的真相 9\n1.4 小测验：缺失的连接线 21\n1.5 调用一个方法时发生了什么 23\n1.6 小测验：混乱的模块 32\n1.7 对象模型小结 35\n第2章 星期二：方法 37\n2.1 一个重复代码的问题 38\n2.2 动态方法 40\n2.3 method_missing()方法 48\n2.4 小测验：狩猎Bug 59\n2.5 关于method_missing()方法的更多内容 61\n第3章 星期三：代码块 69\n3.1 怎样度过驼峰日 70\n3.2 小测验：Ruby的#符号 71\n3.3 闭包 74\n3.4 instance_eval() 83\n3.5 可调用对象 86\n3.6 编写一种领域专属语言 94\n3.7 小测验：更好的领域专属语言 96\n第4章 星期四：类定义 101\n4.1 类定义揭秘 102\n4.2 小测验：Taboo类 109\n4.3 单件方法 110\n4.4 Eigenclass 116\n4.5 小测验：模块的麻烦 129\n4.6 别名 131\n4.7 小测验：打破数学规律 135\n第5章 星期五：编写代码的代码 139\n5.1 带路 139\n5.2 Kernel#eval 142\n5.3 小测验：校验过的属性（第一步） 152\n5.4 小测验：校验过的属性（第二步） 155\n5.5 小测验：校验过的属性（第三步） 157\n5.6 小测验：校验过的属性（第四步） 158\n5.7 钩子方法 159\n5.8 小测验：校验过的属性（第五步） 165\n第6章 尾声 167\n第2部分\u201cRails中的元编程\u201d 169\n第7章 ActiveRecord的设计 171\n7.1 准备旅程 172\n7.2 ActiveRecord的设计 174\n7.3 经验教训 183\n第8章 深入ActiveRecord 187\n8.1 动态属性 187\n8.2 动态查找器 195\n8.3 经验教训 200\n第9章 安全元编程 205\n9.1 元编程的测试 205\n9.2 化解猴子补丁 213\n9.3 经验教训 218\n第三部分 附录 221\n附录A 常见惯用法 223\nA.1 拟态方法 223\nA.2 空指针保护 226\nA.3 关于方法参数的技巧 227\nA.4 Self Yield 231\nA.5 Symbol#to_proc()方法 232\n附录B 领域专属语言 235\nB.1 关于领域专属语言 235\nB.2 内部和外部领域专属语言 237\nB.3 领域专属语言和元编程 238\n附录C 法术手册 239\nC.1 法术集 239\n附录D 参考书目 251\n索引 253","pages":"288","images":{"small":"https://img1.doubanio.com/spic/s7014167.jpg","large":"https://img1.doubanio.com/lpic/s7014167.jpg","medium":"https://img1.doubanio.com/mpic/s7014167.jpg"},"alt":"https://book.douban.com/subject/7056800/","id":"7056800","publisher":"华中科技大学出版社","isbn10":"7560974589","isbn13":"9787560974583","title":"Ruby元编程","url":"https://api.douban.com/v2/book/7056800","alt_title":"Metaprogramming Ruby","author_intro":"Paolo Perrotta有超过10年的软件设计和开发经验，发表过上百篇技术文章。他用过Java、C++、C#编程，最后爱上了Ruby。他是较早接受敏捷方法的实践者，在Yoox（一家大型互联网时尚公司）从事管理敏捷团队的工作。他还在欧洲各国教授编程培训课。目前他和女友（还有一只猫）住在意大利，专心钻研Ruby。","summary":"《Ruby元编程》以案例形式循序渐进讲解Ruby对象模型原理和高级应用技巧，堪称动态语言的设计模式。书中讲述的各种Ruby编程模式，完全可以应用于其他动态语言（甚至静态语言）。本书不仅适合Ruby程序员阅读，也适合对动态编程 语言和面向对象编程感兴趣的读者阅读。所有对程序设计理论感兴趣的人都能从中获益。Ruby之父松本行弘作序推荐。","price":"56.00元"},{"rating":{"max":10,"numRaters":544,"average":"9.0","min":0},"subtitle":"","author":["宋劲杉"],"pubdate":"2009-12","tags":[{"count":639,"name":"Linux","title":"Linux"},{"count":587,"name":"C","title":"C"},{"count":307,"name":"编程","title":"编程"},{"count":160,"name":"计算机","title":"计算机"},{"count":141,"name":"程序设计","title":"程序设计"},{"count":119,"name":"Linux/Unix","title":"Linux/Unix"},{"count":95,"name":"programming","title":"programming"},{"count":74,"name":"嵌入式","title":"嵌入式"}],"origin_title":"","image":"https://img1.doubanio.com/mpic/s24562068.jpg","binding":"平装","translator":[],"catalog":"","pages":"463","images":{"small":"https://img1.doubanio.com/spic/s24562068.jpg","large":"https://img1.doubanio.com/lpic/s24562068.jpg","medium":"https://img1.doubanio.com/mpic/s24562068.jpg"},"alt":"https://book.douban.com/subject/4141733/","id":"4141733","publisher":"电子工业出版社","isbn10":"7121097710","isbn13":"9787121097713","title":"Linux C编程一站式学习","url":"https://api.douban.com/v2/book/4141733","alt_title":"","author_intro":"","summary":"本书有两条线索，一条线索是以Linux平台为载体全面深入地介绍C语言的语法和程序的工作原理，另一条线索是介绍程序设计的基本思想和开发调试方法。本书分为两部分：第一部分讲解编程语言和程序设计的基本思想方法，让读者从概念上认识C语言；第二部分结合操作系统和体系结构的知识讲解程序的工作原理，让读者从本质上认识C语言。.\n本书适合做零基础的初学者学习C语言的第一本教材，帮助读者打下牢固的基础。有一定的编程经验但知识体系不够完整的读者也可以对照本书查缺补漏，从而更深入地理解程序的工作原理。本书最初是为北京亚嵌教育研究中心的嵌入式Linux系统工程师就业班课程量身定做的教材之一，也适合作为高等院校程序设计基础课程的教材。本书对于C语言的语法介绍得非常全面，对C99标准做了很多解读，因此也可以作为一本精简的C语言语法参考书。...","price":"60.00元"},{"rating":{"max":10,"numRaters":637,"average":"7.9","min":0},"subtitle":"程序员职业规划之道","author":["[美] Chad Fowler"],"pubdate":"2010-8","tags":[{"count":344,"name":"程序员","title":"程序员"},{"count":273,"name":"职业生涯","title":"职业生涯"},{"count":265,"name":"职业规划","title":"职业规划"},{"count":137,"name":"编程","title":"编程"},{"count":113,"name":"计算机","title":"计算机"},{"count":71,"name":"程序设计","title":"程序设计"},{"count":67,"name":"软件开发","title":"软件开发"},{"count":65,"name":"Programming","title":"Programming"}],"origin_title":"The Passionate Programmer:Creating A Remarkable Career In Software Development","image":"https://img1.doubanio.com/mpic/s6378707.jpg","binding":"平装","translator":["于梦瑄"],"catalog":"第1章 选择市场\t1\n1 稳定成熟的技术还是未成熟的新技术?\t5\n2 供应和需求\t8\n3 只会编程是不够的\t12\n4 做团队中最差的\t15\n5 在思维上投资\t18\n6 不要听从父母\t21\n7 做一名通才\t27\n8 成为一名专家\t32\n9 切忌孤注一掷\t35\n10 热爱它，不然就离开它\t37\n第2章 在产品上投资\t45\n11 学习钓鱼\t49\n12 学习行业是如何运转的\t52\n13 寻找良师\t54\n14 做一名良师\t58\n15 练习，练习，再练习\t61\n16 做事的方法\t66\n17 站在巨人的肩膀上\t69\n18 在工作中，将自己自动化\t72\n第3章 执行\t79\n19 就是现在\t82\n20 读心术\t84\n21 每日成绩\t87\n22 别忘了你在为谁工作\t90\n23 安分守己\t93\n24 今天我能把工作做到多好？\t96\n25 你的价值是多少\t99\n26 一桶水中的鹅卵石\t102\n27 爱上维护\t105\n28 8小时激情燃烧\t109\n29 学习如何失败\t112\n30 说\u201c不\u201d\t115\n31 不要恐慌\t118\n32 说出来、行动、展示\t122\n第4章 推销\u2026\u2026不仅仅是迎合\t131\n33 不要忽视感觉\t135\n34 探险向导\t138\n35 学会沟通，善于写作\t141\n36 到场\t144\n37 适当的言语\t148\n38 改变世界\t150\n39 让人们听到你的声音\t152\n40 创建自己的商标\t156\n41 发布你编写的程序\t158\n42 变为卓越的能力\t161\n43 建立关系\t164\n第5章 保持技术领先\t171\n44 已经过时的技术\t174\n45 你已经失去工作了\t177\n46 没有终点的道路\t179\n47 给自己做一份蓝图\t181\n48 要注意观察市场变化\t183\n49 镜子里的胖子\t185\n50 南印度捉猴陷阱\t188\n51 避免瀑布型职业计划\t192\n52 每天都有进步\t195\n53 独立\t199\n祝你开心\t203\n参考文献\t204","ebook_url":"https://read.douban.com/ebook/381109/","pages":"202","images":{"small":"https://img1.doubanio.com/spic/s6378707.jpg","large":"https://img1.doubanio.com/lpic/s6378707.jpg","medium":"https://img1.doubanio.com/mpic/s6378707.jpg"},"alt":"https://book.douban.com/subject/4923179/","id":"4923179","publisher":"人民邮电出版社","isbn10":"7115233527","isbn13":"9787115233523","title":"我编程，我快乐","url":"https://api.douban.com/v2/book/4923179","alt_title":"The Passionate Programmer:Creating A Remarkable Career In Software Development","author_intro":"Chad Fowler 国际知名的软件开发人员、培训师、经理、演说家和音乐人。近十年来，他在几家国际知名的公司工作过，与很多受人钦佩的软件开发人员共事。他热爱编程，目前是InfoEther公司的首席技术执行官，主要负责为客户解决Ruby语言上的难题。他还写过软件开发方面的书籍。","summary":"要在当今的IT职场取得成功，必须像经营企业那样对待你的事业。在本书中，你将学到如何规划自己的职业生涯，让它向着你选择的目标前进，使人生更快乐、更美好。\n作者运用其独特的思维方式，启发程序员不能只注重技能上的提高，还要关注自己的职业发展。书中涉及新旧技术的取舍、技术与业务的关系、技术是要专精还是要广博等，相信这也是长久以来困扰你的问题。带着这些问题去阅读此书，定会受益良多。\n此外，本书中的每一章都包含一篇或几篇各领域成功人士的文章，让你直接了解他们如何规划自己的职业生涯！","ebook_price":"18.00","price":"39.00元"}]
     */

    private int count;
    private int start;
    private int total;
    private List<Book> books;

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public int getStart() {
        return start;
    }

    public void setStart(int start) {
        this.start = start;
    }

    public int getTotal() {
        return total;
    }

    public void setTotal(int total) {
        this.total = total;
    }

    public List<Book> getBooks() {
        return books;
    }

    public void setBooks(List<Book> books) {
        this.books = books;
    }
}
